"""
module used to experiment with parametric curves and image rendering
"""

import math
import byte

"""
the poly class

represents a polynomial


attributes:
    c - type: array
    array of numbers that represent the coefficients of the polynomial

        examples:
        an array c = [5, 7] would represent 5x + 7

        an array c = [2, 6, 13] would represent 2x^2 + 6x + 13

functions:
    f - input: number x | output: number
    takes a number x and returns the function of x, using the coefficients from c

        examples:
        with array c = [4, 9] and x = 3, f would return f(3) = 4(3) + 9 = 12 + 9 = 21

        with array c = [1, -5, 12] and x = -2, f would return f(3) = (-2)^2 - 5(-2) + 12 = 4 + 10 + 12 = 26

    pr - no input | no output
    prints the coefficients
"""
class poly:
    def __init__(self,c):
        if len(c) > 0:
            if not c[0] == 0:
                self.c=c
            else:
                count = 0
                run = True
                while run:
                    count += 1
                    if count == len(c):
                        run = False
                    else:
                        if not c[count] == 0:
                            run = False
                self.c = c[count:]
        else:
            self.c=[]
    def f(self,x):
        final = 0
        for i in range(len(self.c)):
            final+=pow(x,len(self.c)-i-1)*self.c[i]
        return final
    def pr(self):
        print(self.c)
"""
the dPoly function - input: poly object | output: poly object
takes a poly object x and returns a poly object with coefficients representing its derivative
"""
def dPoly(x):
    final=[]
    for i in range(len(x.c)-1):
        final.append(x.c[i]*(len(x.c)-i-1))
    return poly(final)

"""
the multPoly function - input: poly object, poly object | output: poly object
takes two poly objects p1 and p2 and returns a poly object with coefficients representing its product
"""
def multPoly(p1,p2):
    final=[]
    finalDeg=len(p1.c)+len(p2.c)-1
    for i in range(finalDeg):
        final.append(0)
    for i in range(len(p1.c)):
        for j in range(len(p2.c)):
            final[i+j]+=p1.c[i]*p2.c[j]
    return poly(final)

"""
the fullNode class

represents a node within a full object

attributes:
    type - type: integer ranged 0 - 3
    represents the type of node
    0 = standard polynomial
    1 = compound expression with references to previously defined values
    2 = rational expression with references to previously defined values
    3 = constant

    value - type: varies(see type)
    represents the value the node, subject to change depending on the type attribute
    type 0 = poly object
    type 1 = two dimensional matrix
    type 2 = array of length 2
    type 3 = number

    function - type: integer ranged 0 - 3
    represents what type of function should be applied to the value generated by the value attribute, invalid when type is 3(constant)
    0 = no function
    1 = square root applied
    2 = sine applied
    3 = cosine applied

    negate - type: boolean
    indicates whether or not the value generated by the value and function attribute should be negated, invalid when type is 3(constant)

    object initiation uses an array of the format [type, value, function, negate]
"""
class fullNode:
    def __init__(self,l):
        self.type = l[0]
        self.value = l[1]
        self.function = 0
        self.negate = False
        if len(l) > 2:
            self.function = l[2]
            self.negate = l[3]
    def pr(self,p):
        if self.type == 0:
            print(p,self.type, self.value.c, self.function, self.negate)
        elif self.type == 1 or self.type == 2:
            print(p,self.type, self.value, self.function, self.negate)
        elif self.type == 3:
            print(p,self.type, self.value)

"""
the full class

represents an expression which could include square root, sine, and cosine functions


attributes:
    l - type: array of fullNode objects
    each entry generates a value that contributes to the final product of the expression

        the final expression is equal to the last value generated in the array

        examples:

        ex 1:
        an array l = [
        [0, poly(9, -5), 1, False]
        ]
        would equate to sqrt(9x - 5), because entry 0 is 0(polynomial), entry 2 is 1(square root), and entry 3 is false(no negation)

        ex 2:
        an array l = [
        [0, poly(6, 11), 2, True]
        ]
        would equate to -sin(6x + 11), because entry 0 is 0(polynomial), entry 2 is 2(sine) and entry 3 is true(negation)


        for array entries where the first entry is 1, the references to previous values are stored where each entry represents a product of its values, and the final value generated is a sum of said products

        ex 3:
        an array l = [
        [3, 4]
        [0, poly(4, -7), 3, False]
        [1, [[0,1]], 0, False]
        ]
        would equate to 4cos(4x - 7), because the first entry in the second value is [0,1], indicating a multiplication of entry 0(constant 4) and entry 1(cosine of 4x - 7)

        ex 4:
        an array l = [
        [0, poly(6, -2), 0, False]
        [0, poly(12, 0), 1, False]
        [1, [[0],[1]], 0, False]
        ]
        would equate to 6x - 2 + sqrt(12x), because the first entry in the second value is [0], and the second entry is [1], indicating a sum of entry 0(6x - 2) and entry 1(square root of 12x)

        ex 5:
        an array l = [
        [3, 5]
        [0, poly(3, 8), 2, False]
        [0, poly(-1, 5), 3, True]
        [1, [[0,1],[2]], 0, False]
        ]
        would equate to 5sin(3x + 8) - cos(-x + 5), because the first entry in the second value is [0,1], indicating a product between entry 0(constant 5) and entry 1(sine of polynomial 3x + 8), and the second entry is [2], indicating a sum of the previous product(5sin(3x + 8)) and entry 2(negated cosine of -x + 5)


        for array entries where the first entry is 2, the first entry is the numerator and the second entry is the denominator

        ex 6:
        an array l = [
        [0, poly(9, -6), 0, False]
        [0, poly(10, 1), 0, False]
        [2, [0,1], 0, False]
        ]
        would equate to (9x - 6)/(10x + 1), because entry 0(9x - 6) in the numerator, and entry 1(10x + 1) is the denominator

functions:
    f - input: number x | output: number
    takes a number x and returns the function of x, using the values from l

        examples:
        using the arrays defined the previous section:

            ex 1 with value 7 = sqrt(9(7) - 5) = sqrt(63 - 5) = sqrt(58) = 7.61
            ex 2 with value -3 = -sin(6(-3) + 11) = -sin(-18 + 11) = -sin(-7) = 0.66
            ex 3 with value 11 = 4cos(4(11) - 7) = 4cos(44 - 7) = 4cos(37) = 3.06
            ex 4 with value 4 = 6(4) - 2 + sqrt(12(4)) = 24 - 2 + sqrt(48) = 22 + sqrt(48) = 22 + sqrt(48) = 28.93
            ex 5 with value 6 = 5sin(3(6) + 8) - cos(-(6) + 5) = 5sin(18 + 8) - cos(-6 + 5) = 5sin(26) - cos(-1) = 3.81 - 0.54 = 3.27
            ex 6 with value -8 = (9(-8) - 6)/(10(-8) + 1) = (-72 - 6)/(-80 + 1) = (-78)/(-79) = 0.99

    append - input: array of length 4 | no output
    takes the given array and add it to l in the form of a fullNode
    
    pr - no input | no output
    prints the values of l in sequential order, used for bugfixes
"""
class full:
    def __init__(self,l):
        self.l=l
    def f(self,x):
        cut=[]
        for i in range(len(self.l)):
            if self.l[i].type == 0:
                sub=self.l[i].value.f(x)
                if self.l[i].function == 1:
                    sub=math.sqrt(sub)
                elif self.l[i].function == 2:
                    sub=math.sin(sub)
                elif self.l[i].function == 3:
                    sub=math.cos(sub)
                if self.l[i].negate:
                    sub=-sub
                cut.append(sub)
            elif self.l[i].type == 1:
                sub2=0
                for j in range(len(self.l[i].value)):
                    sub3=1
                    for k in range(len(self.l[i].value[j])):
                        sub3*=cut[self.l[i].value[j][k]]
                    sub2+=sub3
                if self.l[i].function == 1:
                    sub2=math.sqrt(sub2)
                elif self.l[i].function == 2:
                    sub2=math.sin(sub2)
                elif self.l[i].function == 3:
                    sub2=math.cos(sub2)
                if self.l[i].negate:
                    sub2=-sub2
                cut.append(sub2)
            elif self.l[i].type == 2:
                if not cut[self.l[i].value[1]] == 0:
                    sub2=cut[self.l[i].value[0]]/cut[self.l[i].value[1]]
                else:
                    sub2 = 0
                if self.l[i].function == 1:
                    sub2=math.sqrt(sub2)
                elif self.l[i].function == 2:
                    sub2=math.sin(sub2)
                elif self.l[i].function == 3:
                    sub2=math.cos(sub2)
                if self.l[i].negate:
                    sub2=-sub2
                cut.append(sub2)
            elif self.l[i].type == 3:
                cut.append(self.l[i].value)
        if len(cut) == 0:
            return 0
        else:
            return cut[len(cut)-1]
    def append(self,nl):
        if nl[0] == 1:
            for i in range(len(nl[1])):
                for j in range(len(nl[1][i])):
                    if nl[1][i][j] < 0:
                        nl[1][i][j] += len(self.l)
        elif nl[0] == 2:
            for i in range(len(nl[1])):
                if nl[1][i] < 0:
                    nl[1][i] += len(self.l)
        self.l.append(fullNode(nl))
    def pr(self):
        for k in range(len(self.l)):
            self.l[k].pr(k)
    def s(self):
        return len(self.l)
    def attach(self,y):
        initLen=len(self.l)
        sub2=copyFull(y)
        for i in range(sub2.s()):
            if sub2.l[i].type == 1:
                sub3=[]
                for k in range(len(sub2.l[i].value)):
                    sub3.append([])
                    for n in range(len(sub2.l[i].value[k])):
                        sub3[k].append(sub2.l[i].value[k][n]+initLen)
                self.l.append(sub2.l[i])
                self.l[-1].value=sub3
            elif sub2.l[i].type == 2:
                sub3=[]
                for k in range(len(sub2.l[i].value)):
                    sub3.append(sub2.l[i].value[k]+initLen)
                self.l.append(sub2.l[i])
                self.l[-1].value=sub3
            else:
                self.l.append(sub2.l[i])

"""
the copyFull function - input: full object | output: full object
takes a full object and returns a copy of it
"""
def copyFull(f):
    final=[]
    for i in range(f.s()):
        sub3 = []
        sub3.append(f.l[i].type)
        sub=[]
        if f.l[i].type == 0:
            sub2=[]
            for m in range(len(f.l[i].value.c)):
                sub2.append(f.l[i].value.c[m])
            sub=poly(sub2)
        elif f.l[i].type == 1:
            for k in range(len(f.l[i].value)):
                sub.append([])
                for m in range(len(f.l[i].value[k])):
                    sub[k].append(f.l[i].value[k][m])
        elif f.l[i].type == 2:
            for m in range(len(f.l[i].value)):
                sub.append(f.l[i].value[m])
        elif f.l[i].type == 3:
            sub = f.l[i].value
        sub3.append(sub)
        sub3.append(f.l[i].function)
        sub3.append(f.l[i].negate)
        final.append(fullNode(sub3))
    return full(final)

"""
the dFull function - input: full object | output: full object
takes a full object and returns its derivative
"""
def dFull(f):
    final=copyFull(f)
    cd=[]
    for i in range(len(final.l)):
        validDer=True
        if final.l[i].type == 0:
            if len(final.l[i].value.c)>1:
                if len(final.l[i].value.c)>=2:
                    final.append([0,dPoly(final.l[i].value),0,False])
                else:
                    final.append([3,dPoly(final.l[i].value).c[0]])
            else:
                final.append([3,0])
        elif final.l[i].type == 1:
            sub=[]
            for j in range(len(final.l[i].value)):
                for k in range(len(final.l[i].value[j])):
                    sub.append([])
                    for m in range(len(final.l[i].value[j])):
                        if k == m:
                            sub[-1].append(cd[final.l[i].value[j][m]])
                        else:
                            sub[-1].append(final.l[i].value[j][m])
            final.append([1,sub,0,False])
        elif final.l[i].type == 2:
            final.append([1,[[cd[final.l[i].value[0]],final.l[i].value[1]]],0,False])
            final.append([1,[[final.l[i].value[0],cd[final.l[i].value[1]]]],0,True])
            final.append([1,[[-2],[-1]],0,False])
            final.append([1,[[final.l[i].value[1],final.l[i].value[1]]],0,False])
            final.append([2,[-2,-1],0,False])
        elif final.l[i].type == 3:
            final.append([3,0])
        if final.l[i].type<3:
            if final.l[i].function == 0:
                if not final.l[-1].type == 3:
                    final.l[-1].negate = final.l[i].negate
                else:
                    if final.l[i].negate:
                        final[-1].value *= -1
            elif final.l[i].function == 1:
                final.append([3,2])
                final.append([1,[[i,-1]],0,False])
                final.append([2,[-3,-1],0,False])
            elif final.l[i].function == 2:
                final.append([final.l[i].type,final.l[i].value,3,final.l[i].negate])
                final.append([1,[[-2,-1]],0,False])
            elif final.l[i].function == 3:
                final.append([final.l[i].type,final.l[i].value,2,not final.l[i].negate])
                final.append([1,[[-2,-1]],0,False])
        cd.append(final.s()-1)
    return optFull(final)

def dFull2(f):
    final=copyFull(f)
    cd=[]
    for i in range(len(final.l)):
        validDer=True
        if final.l[i].type == 0:
            if len(final.l[i].value.c)>1:
                if len(final.l[i].value.c)>=2:
                    final.append([0,dPoly(final.l[i].value),0,False])
                else:
                    final.append([3,dPoly(final.l[i].value).c[0]])
            else:
                final.append([3,0])
        elif final.l[i].type == 1:
            sub=[]
            for j in range(len(final.l[i].value)):
                for k in range(len(final.l[i].value[j])):
                    sub.append([])
                    for m in range(len(final.l[i].value[j])):
                        if k == m:
                            sub[-1].append(cd[final.l[i].value[j][m]])
                        else:
                            sub[-1].append(final.l[i].value[j][m])
            final.append([1,sub,0,False])
        elif final.l[i].type == 2:
            final.append([1,[[cd[final.l[i].value[0]],final.l[i].value[1]]],0,False])
            final.append([1,[[final.l[i].value[0],cd[final.l[i].value[1]]]],0,True])
            final.append([1,[[-2],[-1]],0,False])
            final.append([1,[[final.l[i].value[1],final.l[i].value[1]]],0,False])
            final.append([2,[-2,-1],0,False])
        elif final.l[i].type == 3:
            final.append([3,0])
        if final.l[i].type<3:
            if final.l[i].function == 0:
                if not final.l[-1].type == 3:
                    final.l[-1].negate = final.l[i].negate
                else:
                    if final.l[i].negate:
                        final[-1].value *= -1
            elif final.l[i].function == 1:
                final.append([3,2])
                final.append([1,[[i,-1]],0,False])
                final.append([2,[-3,-1],0,False])
            elif final.l[i].function == 2:
                final.append([final.l[i].type,final.l[i].value,3,final.l[i].negate])
                final.append([1,[[-2,-1]],0,False])
            elif final.l[i].function == 3:
                final.append([final.l[i].type,final.l[i].value,2,not final.l[i].negate])
                final.append([1,[[-2,-1]],0,False])
        cd.append(final.s()-1)
    return optFull2(final)

"""
the singleDep function - input: full object, number | output: array
takes a full object and finds out which entries depend on entry e
"""
def singleDep(f,e):
    final=[]
    for i in range(len(f.l)):
        if f.l[i].type == 1:
            sub=False
            for j in range(len(f.l[i].value)):
                for k in range(len(f.l[i].value[j])):
                    if f.l[i].value[j][k] == e:
                        sub=True
            if sub:
                final.append(i)
        elif f.l[i].type == 2:
            if f.l[i].value[0] == e or f.l[i].value[1] == e:
                final.append(i)
    return final

"""
the reverseDependency function - input: full object, s | output: array | recursive
takes a full object and finds out what entries depend on entry s. the function will be called again based off of the entries found. process repeats until only polynomial and constant entries are found
"""
def reverseDependency(f,s):
    if f.l[s].type == 0 or f.l[s].type == 3:
        return []
    final=[]
    final.append(s)
    if f.l[s].type == 1:
        for i in range(len(f.l[s].value)):
            for j in range(len(f.l[s].value[i])):
                final.append(f.l[s].value[i][j])
                sub=reverseDependency(f,f.l[s].value[i][j])
                for k in range(len(sub)):
                    final.append(sub[k])
    elif f.l[s].type == 2:
        for i in range(len(f.l[s].value)):
            final.append(f.l[s].value[i])
            sub=reverseDependency(f,f.l[s].value[i])
            for k in range(len(sub)):
                final.append(sub[k])
    return final

"""
the comp function - input: full object, full object | output: full object
takes two full objects x and y and returns a full object that represents x(y)

example:
with full object x set to l = [[0,poly([5, 7]),2,False]] (sin(5x + 7))
and full object y set to l = [[0,poly([-6, 12]),1,False]] (sqrt(-6x + 12))

product returned would represent sin(5sqrt(-6x + 12) + 7)
"""
def comp(x,y):
    final=copyFull(y)
    sub=copyFull(x)
    samp = []
    initFin = final.s()-1
    for i in range(len(sub.l)):
        if sub.l[i].type == 0:
            for j in range(len(sub.l[i].value.c)):
                final.l.append(fullNode([3,sub.l[i].value.c[j]]))
            sub.l2=[]
            for j in range(len(sub.l[i].value.c)):
                sub.l2.append([])
                for k in range(len(sub.l[i].value.c)-j-1):
                    sub.l2[j].append(initFin)
                sub.l2[j].append(len(final.l)-len(sub.l[i].value.c)+j)
            final.l.append(fullNode([1,sub.l2,sub.l[i].function,sub.l[i].negate]))
            samp.append(final.s()-1)
        elif sub.l[i].type == 1:
            sub.l2=[]
            for j in range(len(sub.l[i].value)):
                sub.l2.append([])
                for k in range(len(sub.l[i].value[j])):
                    sub.l2[j].append(samp[sub.l[i].value[j][k]])
            final.l.append(fullNode([1,sub.l2,sub.l[i].function,sub.l[i].negate]))
            samp.append(final.s()-1)
        elif sub.l[i].type == 2:
            sub.l2=[]
            for j in range(len(sub.l[i].value)):
                sub.l2.append(samp[sub.l[i].value[j]])
            final.l.append(fullNode([2,sub.l2,sub.l[i].function,sub.l[i].negate]))
            samp.append(final.s()-1)
        elif sub.l[i].type == 3:
            final.l.append(fullNode([3,sub.l[i].value]))
            samp.append(final.s()-1)
    return optFull(final)

"""
the orderedPair class

represents an ordered pair

attributes:
    x - type: number
    represents the x coordinate

    y - type: number
    represents the y coordinate

functions:
    pr - no input | no output
    prints the attributes
"""
class orderedPair:
    def __init__(self,x,y):
        self.x=x
        self.y=y
    def ar(self):
        return [self.x,self.y]
    def pr(self):
        print(self.x, self.y)

"""
the pixel class

represents a pixel along a line in a bitmap


attributes:
    pos - type: orderedPair object
    represents the position of a pixel

    magnitude - type: number ranged 0 - 1
    represents the magnitude of the pixel in relation to its line

functions:
    pr - no input | no output
    prints the attributes
"""
class pixel:
    def __init__(self, pos, magnitude):
        self.pos = orderedPair(int(pos.x),int(pos.y))
        self.magnitude = magnitude
    def pr(self):
        self.pos.pr()
        print(self.magnitude)

"""
the para class

represents a parametric curve


attributes:
    x - type: full object
    represents the x component

    y - type: full object
    represents the y component

    isConfig - type: boolean
    indicates whether or not the curve's cached data has been generated

functions:
    f - input: number x | output: orderedPair object
    takes a number x and returns the function of x in the form of an ordered pair
    
    pr - no input | no output
    prints the x and y components of the curve

    findClosest - input: orderedPair object | output: number
    takes a point and finds the distance of the closest point on the self curve that is within the range of 0 and 1

    generatePixels - no input | output: array of pixel objects
    generates a list of pixels required to draw the curve in a bitmap image

    encode - no input | no output:
    encodes the x and y attributes and stores the result in the stream attribute

    decode - input: bytes object | no output:
    takes a bytes object, decodes the result into x and y components, and stores them in the x and y attributes
"""
class para:
    def __init__(self,x,y):
        self.x=x
        self.y=y
        self.isConfig = False
        self.stream = []
    def f(self,x):
        return orderedPair(self.x.f(x),self.y.f(x))
    def pr(self):
        print("x")
        self.x.pr()
        print("\ny")
        self.y.pr()
        print("\n")
    def findClosest(self,p):
        if not self.isConfig:
            configData(self)
        final = 0
        lowest = [dist(p,self.main[0]),0]
        for i in range(len(self.main)):
            sd = dist(p,self.main[i])
            if sd < lowest[0]:
                lowest = [sd,i]
        final = self.positions[lowest[1]]
        if pow(self.deriv[lowest[1]].x,2)+pow(self.deriv[lowest[1]].y,2) > 0:
            startPoint = math.log(pow(self.deriv[lowest[1]].x,2)+pow(self.deriv[lowest[1]].y,2),10)-1
        else:
            startPoint = 1
        for k in range(10):
            for i in range(-10,11,1):
                fp = self.f(final+i/pow(10,k+2+startPoint))
                y = dist(p,fp)
                if i == -10:
                    lowest = [-10,y]
                if y <= lowest[1]:
                    lowest = [i,y]
            final += lowest[0]/pow(10,k+2+startPoint)
            if final > 1:
                final = 1
                break
            if final < 0:
                final = 0
                break
        fp = self.f(final)
        return dist(p,fp)
    def generatePixels(self,th):
        if not self.isConfig:
            configData(self)
        p = 0
        allFinal = []
        dc = dPara(self)
        while p < 1:
            final = []
            initP = self.f(p)
            whole = [(initP.x%1)<pow(10,-6),(initP.y%1)<pow(10,-6)]
            if whole[0] == whole[1]:
                if whole[0]:
                    final.append(initP)
                else:
                    for i in range(4):
                        final.append(orderedPair(math.floor(initP.x)+math.floor(i/2),math.floor(initP.y)+(math.floor((i+1)/2))%2))
            else:
                if whole[0]:
                    for i in range(2):
                        final.append(orderedPair(initP.x,math.floor(initP.y)+i))
                else:
                    for i in range(2):
                        final.append(orderedPair(math.floor(initP.x)+i,initP.y))
            highest = 0
            closeFinal = []
            for i in range(len(final)):
                devCo = dc.f(p)
                mag = math.sqrt(devCo.x*devCo.x+devCo.y*devCo.y)
                if mag == 0:
                    mag = 100
                r = [max(0,p-1/mag),min(1,p+1/mag)]
                fip = p
                run = True
                while run:
                    lp = self.f(r[0])
                    cep = self.f(fip)
                    hp = self.f(r[1])
                    ld = dist(lp,final[i])
                    ced = dist(cep,final[i])
                    hd = dist(hp,final[i])
                    if int(ld*256) == int(ced*256) or int(ced*256) == int(hd*256):
                        run = False
                    if ld < ced and ld < hd:
                        r[1] = fip
                    elif ced < ld and ced < hd:
                        r[0] += (fip-r[0])/2
                        r[1] += (fip-r[1])/2
                    elif hd < ld and hd < ced:
                        r[0] = fip
                    fip = (r[0]+r[1])/2
                fid = 0
                lp = self.f(r[0])
                cep = self.f(fip)
                hp = self.f(r[1])
                ld = dist(lp,final[i])
                ced = dist(cep,final[i])
                hd = dist(hp,final[i])
                if ld < ced and ld < hd:
                    fip = r[0]
                    fid = ld
                elif ced < ld and ced < hd:
                    fid = ced
                elif hd < ld and hd < ced:
                    fip = r[1]
                    fid = hd
                test = [fip, fid]
                if test[1] < 1:
                    closeFinal.append(pixel(final[i],test[1]))
                if test[0] > highest and abs(test[0]-p) < 2/mag:
                    highest = test[0]
            if highest == p:
                dp = dc.f(p)
                mag = math.sqrt(dp.x*dp.x+dp.y*dp.y)
                if mag == 0:
                    mag = 100
                highest = p+1/mag
                if highest > 1:
                    highest = 1
            for i in range(len(closeFinal)):
                allFinal.append(closeFinal[i])
            p = highest
        extFinal = []
        for i in range(len(allFinal)):
            extFinal.append(allFinal[i])
            for j in range(-math.ceil((th-1)/2),math.ceil((th-1)/2)+1):
                for k in range(-math.ceil((th-1)/2),math.ceil((th-1)/2)+1):
                    if not (j == 0 and k == 0):
                        extFinal.append(pixel(orderedPair(allFinal[i].pos.x-j,allFinal[i].pos.y-k),None))
        filteredFinal = []
        for i in range(len(extFinal)):
            found = False
            j = 0
            while j < len(filteredFinal) and not found:
                if extFinal[i].pos.x == filteredFinal[j].pos.x and extFinal[i].pos.y == filteredFinal[j].pos.y:
                    found = True
                j += 1
            if not found:
                if extFinal[i].magnitude == None:
                    extFinal[i].magnitude = self.findClosest(extFinal[i].pos)
                extFinal[i].magnitude -= (th-1)/2
                extFinal[i].magnitude = max(0,extFinal[i].magnitude)
                if extFinal[i].magnitude <= 1:
                    filteredFinal.append(extFinal[i])
        return filteredFinal
    def encode(self):
        finalX = byte.stream()
        for m in range(len(self.x.l)):
            finalX.mBit(0,3)
            finalX.mBit(self.x.l[m].type,2)
            finalX.mBit(self.x.l[m].function,2)
            finalX.bBit(self.x.l[m].negate)
            if self.x.l[m].type == 0:
                finalX.byte(len(self.x.l[m].value.c))
                for n in range(len(self.x.l[m].value.c)):
                    finalX.flo(self.x.l[m].value.c[n])
            elif self.x.l[m].type == 1:
                sub2 = 0
                for n in range(len(self.x.l[m].value)):
                    sub2 += len(self.x.l[m].value[n])
                finalX.byte(sub2)
                for n in range(len(self.x.l[m].value)):
                    for o in range(len(self.x.l[m].value[n])):
                        finalX.fInt(self.x.l[m].value[n][o]+(o == 0)*32768, 2)
            elif self.x.l[m].type == 2:
                finalX.fInt(self.x.l[m].value[0], 2)
                finalX.fInt(self.x.l[m].value[1], 2)
            elif self.x.l[m].type == 3:
                finalX.flo(self.x.l[m].value)
        finalY = byte.stream()
        for m in range(len(self.y.l)):
            finalY.mBit(0,3)
            finalY.mBit(self.y.l[m].type,2)
            finalY.mBit(self.y.l[m].function,2)
            finalY.bBit(self.y.l[m].negate)
            if self.y.l[m].type == 0:
                finalY.byte(len(self.y.l[m].value.c))
                for n in range(len(self.y.l[m].value.c)):
                    finalY.flo(self.y.l[m].value.c[n])
            elif self.y.l[m].type == 1:
                sub2 = 0
                for n in range(len(self.y.l[m].value)):
                    sub2 += len(self.y.l[m].value[n])
                finalY.byte(sub2)
                for n in range(len(self.y.l[m].value)):
                    for o in range(len(self.y.l[m].value[n])):
                        finalY.fInt(self.y.l[m].value[n][o]+(o == 0)*32768, 2)
            elif self.y.l[m].type == 2:
                finalY.fInt(self.y.l[m].value[0], 2)
                finalY.fInt(self.y.l[m].value[1], 2)
            elif self.y.l[m].type == 3:
                finalY.flo(self.y.l[m].value)
        self.stream = []
        for i in range(3):
            self.stream.append(int(len(finalX.l)/pow(256,2-i))%256)
        for i in range(len(finalX.l)):
            self.stream.append(finalX.l[i])
        for i in range(3):
            self.stream.append(int(len(finalY.l)/pow(256,2-i))%256)
        for i in range(len(finalY.l)):
            self.stream.append(finalY.l[i])
    def decode(self,stream):
        self.stream = stream
        sub = byte.parser(stream[3:3+byte.parse(stream[0:3])])
        sub2 = []
        while sub.count < len(sub.l):
            specByte = sub.sPar()
            nType = int((specByte%32)/8)
            function = int((specByte%8)/2)
            negate = specByte%2
            value = 0
            if nType == 0:
                sub3 = []
                cLen = sub.sPar()
                for i in range(cLen):
                    sub3.append(sub.fPar())
                value = poly(sub3)
            elif nType == 1:
                sub3 = []
                cLen = sub.sPar()
                for i in range(cLen):
                    sub4 = sub.lPar(2)
                    if sub4 >= 32768:
                        sub3.append([])
                    sub3[-1].append(sub4%32768)
                value = sub3
            elif nType == 2:
                value = [sub.lPar(2), sub.lPar(2)]
            elif nType == 3:
                value = sub.fPar()
            sub2.append(fullNode([nType,value,function,negate]))
        self.x = full(sub2)
        xLen = byte.parse(stream[0:3])+3
        sub = byte.parser(stream[xLen+3:xLen+3+byte.parse(stream[xLen:xLen+3])])
        sub2 = []
        while sub.count < len(sub.l):
            specByte = sub.sPar()
            nType = int((specByte%32)/8)
            function = int((specByte%8)/2)
            negate = specByte%2
            value = 0
            if nType == 0:
                sub3 = []
                cLen = sub.sPar()
                for i in range(cLen):
                    sub3.append(sub.fPar())
                value = poly(sub3)
            elif nType == 1:
                sub3 = []
                cLen = sub.sPar()
                for i in range(cLen):
                    sub4 = sub.lPar(2)
                    if sub4 >= 32768:
                        sub3.append([])
                    sub3[-1].append(sub4%32768)
                value = sub3
            elif nType == 2:
                value = [sub.lPar(2), sub.lPar(2)]
            elif nType == 3:
                value = sub.fPar()
            sub2.append(fullNode([nType,value,function,negate]))
        self.y = full(sub2)
        yLen = byte.parse(stream[xLen:xLen+3])+3
        return xLen+yLen

"""
the daCent function - input: orderedPair object | output: number ranged 0 - 360
takes an ordered pair and find the angle it makes with the origin in standard notation
"""
def daCent(p):
    final=0
    if p.x == 0:
        if p.y > 0:
            final=90
        if p.y < 0:
            final=-90
    else:
        final = math.atan(p.y/p.x)*180/math.pi
    if p.x < 0:
        final+=180
    if p.x > 0 and p.y < 0:
        final+=360
    return final

"""
the da2 function - input: orderedPair object, orderedPair object | output: number ranged 0 - 360
takes two ordered pairs and finds the angle created by line from p1 to p2 in standard notation
"""
def da2(p1,p2):
    fp = orderedPair(p2.x-p1.x,p2.y-p1.y)
    return daCent(fp)

"""
the configData function - input: para object | no output
takes a para curve and generates data that is stored for later. data includes a main point list, derivative point list, double derivative point list, length, angle measurement of the initial vector, and angle measurement of the terminal vector
"""
def configData(f):
    if not f.isConfig:
        f.isConfig = True
        f.positions = []
        f.main = []
        f.deriv = []
        f.doubleDeriv = []
        f.length = 0
        finalPos = []
        df = dPara(f)
        ddf = dPara(df)
        p = 0
        fp = f.f(p)
        dp = df.f(p)
        ddp = ddf.f(p)
        f.positions.append(p)
        f.main.append(fp)
        f.deriv.append(dp)
        f.doubleDeriv.append(ddp)
        f.conX = True
        f.conY = True
        if dp.x == 0 and dp.y == 0:
            f.positions.append(p)
            f.main.append(fp)
            f.deriv.append(dp)
            f.doubleDeriv.append(ddp)
            f.length += dist(f.main[-2],f.main[-1])
            p = 0.01
            fp = f.f(p)
            dp = df.f(p)
            ddp = ddf.f(p)
            if not ddp.x == 0:
                f.conX = False
            if not ddp.y == 0:
                f.conY = False
        while p < 1:
            f.positions.append(p)
            f.main.append(fp)
            f.deriv.append(dp)
            f.doubleDeriv.append(ddp)
            if len(f.main) > 1:
                f.length += dist(f.main[-2],f.main[-1])
            mag = math.sqrt(pow(dp.x,2)+pow(dp.y,2))
            pMag = 1000
            if mag > 0:
                pMag = mag
                p += 1/mag
            else:
                p += 1/pMag
            fp = f.f(p)
            dp = df.f(p)
            ddp = ddf.f(p)
            if not ddp.x == 0:
                f.conX = False
            if not ddp.y == 0:
                f.conY = False
        if len(finalPos) >= 2:
            finalPos[-1] = (finalPos[-2]+1)/2
            final[-1] = f.f(finalPos[-1])
        p = 1
        fp = f.f(p)
        dp = df.f(p)
        ddp = ddf.f(p)
        f.positions.append(p)
        f.main.append(fp)
        f.deriv.append(dp)
        f.doubleDeriv.append(ddp)
        f.length += dist(f.main[-2],f.main[-1])
        f.startAn = 0
        if f.deriv[0].x == 0 and f.deriv[0].y == 0:
            f.startAn = daCent(df.f(0.000001))
        else:
            f.startAn = daCent(f.deriv[0])
        f.endAn = 0
        if f.deriv[-1].x == 0 and f.deriv[-1].y == 0:
            f.endAn = daCent(df.f(0.999999))
        else:
            f.endAn = daCent(f.deriv[-1])
"""
the dPara function - input: para object | output: para object
takes a para object and returns the derivative of its x and y attributes as another para object
"""
def dPara(x):
    return para(dFull(x.x),dFull(x.y))

"""
the copyPara function - input: para object | output: para object
takes a para object and returns a copy of it
"""
def copyPara(x):
    return para(copyFull(x.x),copyFull(x.y))

"""
the optPara function - input: para object | output: para object
takes a para object, optimizes its x and y attributes, and returns the result as another para object
"""
def optPara(x):
    sub = para(optFull(x.x),optFull(x.y))
    return sub

"""
the pascal function - input: positive nonzero integer, positive nonzero integer | output: nonzero integer
takes two nonzero integers r and n and returns the number in the position specified in pascals triangle(r means row, n means column)

output is defined as r!/(n! * (r-n)!)
"""
def pascal(r,n):
    return math.factorial(r)/(math.factorial(n)*math.factorial(r-n))

"""
the bez function - input: orderedPair object, array of orderedPair objects, orderedPair | output: para object
using an orderedPair object as a start point, an array of orderedPair objects as control points, and another orderedPair object as an end point, function returns a bezier curve in the form of a para object
"""
def bez(sc,cpl,ec):
    co=[sc]
    for i in range(len(cpl)):
        co.append(cpl[i])
    co.append(ec)
    pol=[[],[]]
    for i in range(len(co)):
        t=0
        w=0
        for j in range(len(co)-i):
            t+=co[j].x*pascal(len(co)-i-1,j)*pow(-1,j+1+i)
            w+=co[j].y*pascal(len(co)-i-1,j)*pow(-1,j+1+i)
        pol[0].append(pascal(len(co)-1,i)*t*pow(-1,len(co)))
        pol[1].append(pascal(len(co)-1,i)*w*pow(-1,len(co)))
    return para(full([fullNode([0,poly(pol[0]),0,False])]),full([fullNode([0,poly(pol[1]),0,False])]))

"""
the spiral function - input: number, number, number, number, number, number | output: para object
takes six numbers and returns a spiral curve in the form of a para object
"""
def spiral(x,y,br,fr,dof,da):
    return para(full([fullNode([3,x]),fullNode([0,poly([fr-br,br]),0,False]),fullNode([0,poly([da*math.pi/180,dof*math.pi/180]),3,False]),fullNode([1,[[0],[1,2]],0,False])]),full([fullNode([3,y]),fullNode([0,poly([fr-br,br]),0,False]),fullNode([0,poly([da*math.pi/180,dof*math.pi/180]),2,False]),fullNode([1,[[0],[1,2]],0,False])]))

"""
the compCurve function - input: para object, para object | output: para object
takes the x component of para object x and takes the y component of para object y and returns a new para objects with the x and y components taken
"""
def compCurve(x,y):
    return para(x.x,y.y)

"""
the transformationNode class

represents values used in the transformation of a curve

attributes:
    type - type: integer ranged 0 - 2
    represents the type of transformation operation carried out
    0: translation
    1: rotation
    2: scale

    value1 - type: number
    represents the first transformation value
    type 0: translation along the x axis
    type 1: degrees rotated about the origin
    type 2: scale along the x axis

    value2 - type: number
    represents the second transformation value if applicable
    type 0: translation along the y axis
    type 1: n/a
    type 2: scale along the y axis

    object initiation uses an array of the format [type, value1, value2]
"""
class transformationNode:
    def __init__(self,l):
        self.type=l[0]
        self.value1=l[1]
        self.value2=0
        if len(l) > 2:
            self.value2=l[2]
"""
the transformCurve function - input: array of para objects, array of transformNode objects | output: para object
takes the array of para objects x, uses the array of transformNode objects to transform the curves
"""
def transformCurve(x,tn):
    sub2 = []
    for i in range(len(x)):
        final=copyPara(x[i])
        for j in range(len(tn)):
            if tn[j].type == 0:
                final.x.append([3,tn[j].value1])
                final.x.append([1,[[final.x.s()-2],[final.x.s()-1]],0,False])
                final.y.append([3,tn[j].value2])
                final.y.append([1,[[final.y.s()-2],[final.y.s()-1]],0,False])
            if tn[j].type == 1:
                sub=copyFull(final.x)
                xe=sub.s()-1
                sub.attach(final.y)
                ye=sub.s()-1
                sub.append([3,math.cos(tn[j].value1*math.pi/180)])
                xl=copyFull(sub)
                xl.append([3,-math.sin(tn[j].value1*math.pi/180)])
                yl=copyFull(sub)
                yl.append([3,math.sin(tn[j].value1*math.pi/180)])
                xl.append([1,[[xe,xl.s()-2],[ye,xl.s()-1]],0,False])
                yl.append([1,[[ye,yl.s()-2],[xe,yl.s()-1]],0,False])
                final=para(xl,yl)
            if tn[j].type == 2:
                final.x.append([3,tn[j].value1])
                final.x.append([1,[[final.x.s()-2,final.x.s()-1]],0,False])
                final.y.append([3,tn[j].value2])
                final.y.append([1,[[final.y.s()-2,final.y.s()-1]],0,False])
        sub2.append(optPara(final))
    return sub2

"""
the horShift function - input: poly object, number | output: poly object
takes a polynomial and horizontally shifts it by x units
"""
def horShift(p,x):
    f=[]
    for i in range(len(p.c)):
        f.append(p.c[i])
    final=[]
    for i in range(len(f)):
        final.append(0)
    for i in range(len(f)):
        sub=poly([f[i]])
        for j in range(len(f)-i-1):
            sub=multPoly(sub,poly([1,-x]))
        for j in range(len(sub.c)):
            final[i+j]+=sub.c[j]
    return poly(final)

"""
the slice function - input: poly object, number, number | output: poly object
takes a polynomial slices it. result is a poly object with new start point at position s and new end point at position e
"""
def slicePoly(p,s,e):
    f=[]
    for i in range(len(p.c)):
        f.append(p.c[i])
    ns = e-s
    final=poly([])
    for i in range(len(f)):
        final.c.append(f[i])
    final=horShift(final,-s)
    for i in range(len(f)):
        final.c[i]*=pow(ns,len(f)-1-i)
    return final

"""
the quickTransform class

represents an alternative form of transformation for mapped curves

attributes:
    scale - type: number
    represents the amount the final product should be scaled by

    translation - type: number
    represents the amount the final product should be translated by after its been scaled
"""
class quickTransform:
    def __init__(self,scale,translation):
        self.scale=scale
        self.translation=translation

"""
the wrap function - input: para object, full object, quickTransform object | output: poly object
takes a polynomial and finds the "wraped" version of it based off an expression represented by a full object
"""
def wrap(x,a,t):
    xSuff=copyFull(a)
    xSuff.append([3,t.scale])
    xSuff.append([3,t.translation])
    xSuff.append([1,[[-3,-2],[-1]],0,False])
    ySuff=copyFull(a)
    ySuff.append([3,t.scale])
    ySuff.append([3,t.translation])
    ySuff.append([1,[[-3,-2],[-1]],0,True])
    sub=copyFull(x.x)
    if len(x.x.l) == 0:
        sub.append([3,0])
    xi=sub.s()-1
    dx = dFull(x.x)
    if len(dx.l) > 0:
        sub.attach(dx)
    else:
        sub.append([3,0])
    dxi=sub.s()-1
    if len(x.y.l) > 0:
        sub.attach(x.y)
    else:
        sub.append([3,0])
    yi=sub.s()-1
    dy = dFull(x.y)
    if len(dy.l) > 0:
        sub.attach(dy)
    else:
        sub.append([3,0])
    dyi=sub.s()-1
    sub.append([1,[[dxi,dxi],[dyi,dyi]],1,False])
    den=sub.s()-1
    xl=copyFull(sub)
    yl=copyFull(sub)
    xl.attach(xSuff)
    yl.attach(ySuff)
    xl.append([1,[[-1,dyi]],0,False])
    xl.append([2,[-1,den],0,False])
    xl.append([1,[[xi],[-1]],0,False])
    yl.append([1,[[-1,dxi]],0,False])
    yl.append([2,[-1,den],0,False])
    yl.append([1,[[yi],[-1]],0,False])
    return optPara(para(xl,yl))

"""
the scopeDimensions class

represents a scope field used by warp operations

attributes:
    w - type: number
    represents the width of the scope

    h - type: number
    represents the height of the scope
"""
class scopeDimensions:
    def __init__(self,w,h):
        self.w=w
        self.h=h

"""
the singleWarp function - input: para object, array of para objects, scopeDimensions object, quickTransform object | output: para object
takes an array of para objects and maps them to one base para object using the scopeDimensions and quickTranslate objects
"""
def singleWarp(b,sl,d,o):
    final = []
    for z in range(len(sl)):
        s = sl[z]
        sx=copyFull(s.x)
        sx.append([3,o.x])
        sx.append([1,[[-2],[-1]],0,False])
        sx.append([3,d.w])
        sx.append([2,[-2,-1],0,False])
        sy=copyFull(s.y)
        sy.append([3,o.y])
        sy.append([1,[[-2],[-1]],0,False])
        sy.append([3,d.h])
        sy.append([2,[-2,-1],0,False])
        xc=comp(b.x,sx)
        yc=comp(b.y,sx)
        dxc=comp(dFull(b.x),sx)
        dyc=comp(dFull(b.y),sx)
        xl=copyFull(sy)
        yl=copyFull(sy)
        syi=xl.s()-1
        xl.attach(xc)
        xci=xl.s()-1
        xl.attach(dyc)
        dyci=xl.s()-1
        xl.append([1,[[xci],[syi,dyci]],0,False])
        yl.attach(yc)
        yci=yl.s()-1
        yl.attach(dxc)
        if yl.l[-1].type<3:
            yl.l[-1].negate = not yl.l[-1].negate
        else:
            yl.l[-1][1]*=-1
        dxci=yl.s()-1
        yl.append([1,[[yci],[syi,dxci]],0,False])
        final.append(optPara(para(xl,yl)))
    return final

"""
the midpoint function - input: ps object, ps object | output: orderedPair or None
takes two points and finds the midpoint
"""
def midpoint(a,b):
    return orderedPair((a.x+b.x)/2,(a.y+b.y)/2)

"""
the dist function - input: orderedPair object, orderedPair object | output: positive number
takes two points and finds the distance between them
"""
def dist(a,b):
    return math.sqrt(pow(b.x-a.x,2)+pow(b.y-a.y,2))

"""
the fillSquare class

represents a square region

attributes:
    center - type: orderedPair object
    represents the center of the square

    size - type: positive number
    represents the size of the square
"""
class fillSquare:
    def __init__(self,center,size):
        self.center = center
        self.size = size

"""
the insertIn function - input: value, array, positive integer | output: array
takes an array and inserts a value at a certain index
"""
def insertIn(v,l,ind):
    final = []
    for i in range(ind):
        final.append(l[i])
    final.append(v)
    for i in range(ind,len(l)):
        final.append(l[i])
    return final

"""
the ps class

represents a point slope equation in the form of y = mx + b

attributes:
    yFunc - type: boolean
    represents whether the equation is one of x or y. if true, the equation is in the format y = mx + b. if false, the equation is in the format x = my + b

    m - type: number ranged 0 - 1
    represents the slope of the equation

    b - type: number
    represents the intercept of the equation
functions:
    f - input: number | output: number
    takes a number x and returns the function of the number, using the attributes m and b

    pc - input: number orderedPair object | output: boolean
    takes an ordered pair and returns true if the point is found on the positive side of the line, false if otherwise

    pr - input: no input | no output
    prints the m, b, and yFunc attributes

    angDir - input: orderedPair object | output: boolean
    takes an ordered pair and returns true if the angular direction of it is positive
"""
class ps:
    def __init__(self, p1, p2):
        difX = p2.x-p1.x
        difY = p2.y-p1.y
        self.yFunc=abs(difX)>abs(difY)
        if self.yFunc:
            self.m = difY/difX
            self.b = -self.m*p1.x+p1.y
        else:
            self.m = difX/difY
            self.b = -self.m*p1.y+p1.x
    def f(self,x):
        if self.yFunc:
            return orderedPair(x,self.m*x+self.b)
        else:
            return orderedPair(self.m*x+self.b,x)
    def pc(self, p):
        if self.yFunc:
            test = self.f(p.x)
            return p.y > test.y
        else:
            test = self.f(p.y)
            return p.x > test.x
    def pr(self):
        print(self.m, self.b, self.yFunc)
    def angDir(self,p):
        if self.yFunc:
            return (p.y-self.m*p.x-self.b)/(pow(p.y-self.b,2)+pow(p.x,2)) > 0
        else:
            return (p.x-self.m*p.y-self.b)/(pow(p.x-self.b,2)+pow(p.y,2)) < 0

"""
the psInter function - input: ps object, ps object | output: orderedPair or None
takes two ps objects l1 and l2 and returns their intersection point in the form of an orderedPair object. if their m and yFunc attributes are the same, then None is returned
"""
def psInter(l1,l2):
    final = [None,None]
    if l1.yFunc == l2.yFunc:
        if not l1.m == l2.m:
            final = [(l2.b-l1.b)/(l1.m-l2.m),(l2.b-l1.b)/(l1.m-l2.m)*l1.m+l1.b]
    else:
        final = [(l2.m*l1.b+l2.b)/(1-l1.m*l2.m),(l1.m*l2.b+l1.b)/(1-l1.m*l2.m)]
    if l1.yFunc:
        return orderedPair(final[0],final[1])
    else:
        return orderedPair(final[1],final[0])

"""
the intersection class

represents the intersections between two curves

attributes:
    prog1 - type: number ranged 0 - 1
    represents the progress of the first curve to the intersection point

    prog2 - type: number ranged 0 - 1
    represents the progress of the second curve to the intersection point

functions:
    pr - input: no input | no output
    prints the prog1 and prog2 attributes
"""
class intersection:
    def __init__(self,prog1,prog2):
        self.prog1=prog1
        self.prog2=prog2
    def pr(self):
        print(self.prog1,self.prog2)

"""
the detectInter function - input: para object, para object, boolean | output: array of intersection objects or array of orderedPair objects
takes two curves and finds any intersections between them. if returnProg is true, the estimated progress values are stored in an array of intersection objects. if false, the actual intersection coordinates are returned in an array of orderedPair objects
"""
def detectInter(c1,c2,returnProg):
    exportValues = []
    for i in range(len(c1.main)-1):
        for j in range(len(c2.main)-1):
            if not ((c1.main[i].x == c1.main[i+1].x and c1.main[i].y == c1.main[i+1].y) or (c2.main[j].x == c2.main[j+1].x and c2.main[j].y == c2.main[j+1].y)):
                p1 = 0
                p2 = 0
                s1 = ps(c1.main[i],c1.main[i+1])
                s2 = ps(c2.main[j],c2.main[j+1])
                inte = psInter(s1, s2)
                if not inte.x == None:
                    if s1.yFunc:
                        p1 = (inte.x-c1.main[i].x)/(c1.main[i+1].x-c1.main[i].x)
                    else:
                        p1 = (inte.y-c1.main[i].y)/(c1.main[i+1].y-c1.main[i].y)
                    if s2.yFunc:
                        p2 = (inte.x-c2.main[j].x)/(c2.main[j+1].x-c2.main[j].x)
                    else:
                        p2 = (inte.y-c2.main[j].y)/(c2.main[j+1].y-c2.main[j].y)
                else:
                    p1 = 1.1
                if p1>=0 and p1<=1 and p2>=0 and p2<=1:
                    if returnProg:
                        exportValues.append(intersection(c1.positions[i]+(c1.positions[i+1]-c1.positions[i])*p1,c2.positions[j]+(c2.positions[j+1]-c2.positions[j])*p2))
                    else:
                        exportValues.append(inte)
    return exportValues

"""
the bounds class

represents a rectangular range

attributes:
    minX - type: number
    represents the minimum x value

    minY - type: number
    represents the minimum y value

    maxX - type: number
    represents the maximum x value

    maxY - type: number
    represents the maximum y value

functions:
    pr - input: no input | no output
    prints all attributes
"""
class bounds:
    def __init__(self,minX,minY,maxX,maxY):
        self.minX = minX
        self.minY = minY
        self.maxX = maxX
        self.maxY = maxY
    def inBounds(self,p,o):
        return p.x > self.minX-o and p.x < self.maxX+o and p.y > self.minY-o and p.y < self.maxY+o
    def pr(self):
        print(self.minX, self.minY, self.maxX, self.maxY)

"""
the overlap function - input: bounds object, bounds object | output: boolean
takes two bounds objects and returns true if their ranges overlap
"""
def overlap(b1,b2):
    return b1.maxX > b2.minX and b1.minX < b2.maxX and b1.maxY > b2.minY and b1.minY < b2.maxY

"""
the qComp function - input: number, number | output: boolean
takes two numbers and returns true if they are close enough in proximity
"""
def qComp(a,b):
    return abs(a-b)<pow(10,-6)

"""
the pComp function - input: orderedPair object, orderedPair object | output: boolean
takes two points and returns true if they are close enough in proximity
"""
def pComp(a,b):
    return dist(a,b)<pow(10,-6)

"""
the rearrange function - input: array of para objects | output: array of para objects or none
takes an array of para objects and returns a sequence representing an enclosed path. if no path can be made, none is returned
"""
def rearrange(cl):
    inds = [0]
    dirs = [True]
    closed = False
    count = 1
    ep = cl[inds[0]].f(1)
    rejected = []
    while not closed:
        if not count in inds and not count in rejected:
            if pComp(ep,cl[count].f(0)):
                inds.append(count)
                dirs.append(True)
                count = 0
            elif pComp(ep,cl[count].f(1)):
                inds.append(count)
                dirs.append(False)
                count = 0
        count += 1
        ep = cl[inds[-1]].f(dirs[-1])
        if pComp(ep,cl[0].f(0)):
            closed = True
        if count == len(cl) and not closed:
            rejected.append(inds[-1])
            inds[-1:] = []
            dirs[-1:] = []
            count = 1
            if len(inds) == 0:
                return None
    final = []
    for i in range(len(inds)):
        if dirs[i]:
            final.append(cl[inds[i]])
        else:
            final.append(slicePara(cl[inds[i]],1,0))
    return final

"""
the prism class

represents a group of curves that make an enclosed area

attributes:
    cl - type: array of para objects
    represents the "sides" of the prism

    isPrism - type: boolean
    indicated whether or not the group of curves presented forms a prism. set to true if each curve's end point equals the next curve's start point

    if isPrism is true after the check, then the following variables are set:
    direction - type: 1 or -1
    indicates the direction of the path in which the prism travels. set to 1 if counter-clockwise, -1 if clockwise

    area - type: positive number
    represents the area of the enclosure

    perimeter - type: positive number
    represents the total combined length of the border curves

    bounds - type: bounds object
    represents the minimum and maximum x and y values of the prism

functions:
    inside - input: orderedPair object, boolean | output: boolean
    takes an ordered pair and determines whether or not the point lies within the prism. returns true if it is within the enclosure, false if otherwise. however, if norm is set to false, then true is returned if the point lies outside the enclosure, false if otherwise. in the event that the point lies very close a border curve, true is returned regardless

    fill - positive number, positive number, boolean | output: array of fillSquare objects
    takes the prism and fills its enclosure using fillSquare objects. maxSize and minSize are used as limiters to the size of the fillSquare objects used. if norm is set to False, then the area outside the prism is filled in using fillSquares
"""
class prism:
    def __init__(self,cl):
        self.cl = rearrange(cl)
        self.isPrism = (not self.cl == None)
        self.direction = 0
        self.area = 0
        self.perimeter = 0
        self.center = orderedPair(0,0)
        self.bounds = bounds(0,0,0,0)
        if self.isPrism:
            for i in range(len(self.cl)):
                configData(self.cl[i])
            final = 0
            nex = 0
            self.bounds = bounds(self.cl[0].main[0].x,self.cl[0].main[0].y,self.cl[0].main[0].x,self.cl[0].main[0].y)
            for i in range(len(self.cl)):
                self.perimeter += self.cl[i].length
                subX = 0
                subY = 0
                for j in range(len(self.cl[i].main)-1):
                    if self.cl[i].main[j].x < self.bounds.minX:
                        self.bounds.minX = self.cl[i].main[j].x
                    if self.cl[i].main[j].x > self.bounds.maxX:
                        self.bounds.maxX = self.cl[i].main[j].x
                    if self.cl[i].main[j].y < self.bounds.minY:
                        self.bounds.minY = self.cl[i].main[j].y
                    if self.cl[i].main[j].y > self.bounds.maxY:
                        self.bounds.maxY = self.cl[i].main[j].y
                    sp = midpoint(self.cl[i].main[j],self.cl[i].main[j+1])
                    dsp = midpoint(self.cl[i].deriv[j],self.cl[i].deriv[j+1])
                    ddsp = midpoint(self.cl[i].doubleDeriv[j],self.cl[i].doubleDeriv[j+1])
                    mag = self.cl[i].positions[j+1]-self.cl[i].positions[j]
                    if pow(dsp.x,2)+pow(dsp.y,2) > 0:
                        final += (dsp.x*ddsp.y-dsp.y*ddsp.x)/(pow(dsp.x,2)+pow(dsp.y,2))*mag
                    self.area += (sp.x*dsp.y-sp.y*dsp.x)/2*mag
                    subX += sp.x*mag
                    subY += sp.y*mag
                if self.cl[i].main[-1].x < self.bounds.minX:
                    self.bounds.minX = self.cl[i].main[-1].x
                if self.cl[i].main[-1].x > self.bounds.maxX:
                    self.bounds.maxX = self.cl[i].main[-1].x
                if self.cl[i].main[-1].y < self.bounds.minY:
                    self.bounds.minY = self.cl[i].main[-1].y
                if self.cl[i].main[-1].y > self.bounds.maxY:
                    self.bounds.maxY = self.cl[i].main[-1].y
                self.center.x += subX/len(self.cl)
                self.center.y += subY/len(self.cl)
                if i < len(self.cl)-1:
                    nex = (self.cl[i+1].startAn-self.cl[i].endAn)*math.pi/180
                    if abs(self.cl[i+1].startAn-self.cl[i].endAn) == 180:
                        if daCent(self.cl[i+1].f(0.000001))-daCent(self.cl[i].f(0.999999)) > 0:
                            nex = math.pi
                        else:
                            nex = -math.pi
                    if nex > math.pi:
                        nex -= (2*math.pi)
                    elif nex < -math.pi:
                        nex += (2*math.pi)
                    final += nex
            nex = (self.cl[0].startAn-self.cl[-1].endAn)*math.pi/180
            if abs(self.cl[0].startAn-self.cl[-1].endAn) == 180:
                if daCent(self.cl[0].f(0.000001))-daCent(self.cl[-1].f(0.999999)) > 0:
                    nex = math.pi
                else:
                    nex = -math.pi
            if nex > math.pi:
                nex -= 2*math.pi
            elif nex < -math.pi:
                nex += 2*math.pi
            final += nex
            self.direction = round(final/(2*math.pi))
            self.area = abs(self.area)
    def inside(self,p,norm):
        final = 0
        lDist = 100
        for i in range(len(self.cl)):
            sDist = self.cl[i].findClosest(p)
            if sDist < lDist:
                lDist = sDist
            for j in range(len(self.cl[i].main)-1):
                sp = midpoint(self.cl[i].main[j],self.cl[i].main[j+1])
                sp.x -= p.x
                sp.y -= p.y
                dsp = midpoint(self.cl[i].deriv[j],self.cl[i].deriv[j+1])
                mag = self.cl[i].positions[j+1]-self.cl[i].positions[j]
                if pow(sp.x,2)+pow(sp.y,2) > 0:
                    final += (sp.x*dsp.y-sp.y*dsp.x)/(pow(sp.x,2)+pow(sp.y,2))*mag
        if norm:
            if round(final/(math.pi*2))*self.direction >= 1:
                return True
            else:
                if lDist < pow(10,-6):
                    return True
                else:
                    return False
        else:
            if round(final/(math.pi*2))*self.direction <= 0:
                return True
            else:
                if lDist < pow(10,-6):
                    return True
                else:
                    return False
    def fill(self,maxSize,minSize,norm):
        sizes = [maxSize]
        while sizes[-1] > minSize:
            sizes.append(sizes[-1]/2)
        final = []
        run = True
        while run:
            ab = [[0,0],[0,0]]
            ab[0][0] = math.floor(self.bounds.minX/sizes[0])*sizes[0]
            ab[0][1] = math.floor(self.bounds.minY/sizes[0])*sizes[0]
            ab[1][0] = math.ceil(self.bounds.maxX/sizes[0])*sizes[0]
            ab[1][1] = math.ceil(self.bounds.maxY/sizes[0])*sizes[0]
            sp = []
            i = ab[0][0]
            while i <= ab[1][0]:
                j = ab[0][1]
                while j <= ab[1][1]:
                    sp.append([i,j,self.inside(orderedPair(i,j),norm)])
                    j += sizes[0]
                i += sizes[0]
            if len(sp) > 4:
                for j in range(len(sp)):
                    if sp[j][2] == True:
                        run = False
                if run:
                    sizes[0:1] = []
            else:
                sizes[0:1] = []
        confirmed = []
        for x in range(len(sizes)):
            s = sizes[x]
            pointPos = []
            if x == 0:
                pointPos = sp
            else:
                pointPos = final[x-1][0]
            pc = []
            if x > 0:
                pc = final[x-1][1]
            points = []
            for i in range(len(pointPos)):
                points.append(pointPos[i][2])
            newBlocks = []
            for i in range(len(points)):
                sub = [points[i],-1,-1,-1,pointPos[i]]
                j = i-1
                run = True
                if j < 0:
                    run = False
                while run:
                    if pointPos[i][0] == pointPos[j][0] and pointPos[i][1] == pointPos[j][1]+s:
                        newBlocks[j][1] = points[i]
                    if pointPos[i][0] == pointPos[j][0]+s and pointPos[i][1] == pointPos[j][1]:
                        newBlocks[j][2] = points[i]
                    if pointPos[i][0] == pointPos[j][0]+s and pointPos[i][1] == pointPos[j][1]+s:
                        newBlocks[j][3] = points[i]
                    if pointPos[i][0]-pointPos[j][0] > s:
                        run = False
                    j-=1
                    if j < 0:
                        run = False
                newBlocks.append(sub)
            for i in range(len(newBlocks)-1,-1,-1):
                if newBlocks[i][1] == -1 or newBlocks[i][2] == -1 or newBlocks[i][3] == -1:
                    newBlocks[i:i+1] = []
            classBlocks = []
            for i in range(len(pc)):
                classBlocks.append([pc[i][0],pc[i][1],3,[True,True,True,True]])
                classBlocks.append([pc[i][0]+s,pc[i][1],3,[True,True,True,True]])
                classBlocks.append([pc[i][0]+s,pc[i][1]+s,3,[True,True,True,True]])
                classBlocks.append([pc[i][0],pc[i][1]+s,3,[True,True,True,True]])
            for i in range(len(newBlocks)):
                sub = 0
                sub2 = para(0,0)
                sub2.main = [orderedPair(newBlocks[i][4][0],newBlocks[i][4][1]),orderedPair(newBlocks[i][4][0]+s,newBlocks[i][4][1]),orderedPair(newBlocks[i][4][0]+s,newBlocks[i][4][1]+s),orderedPair(newBlocks[i][4][0],newBlocks[i][4][1]+s),orderedPair(newBlocks[i][4][0],newBlocks[i][4][1])]
                if newBlocks[i][0] and newBlocks[i][1] and newBlocks[i][2] and newBlocks[i][3]:
                    sub5 = True
                    for j in range(len(self.cl)):
                        sub4 = detectInter(sub2,self.cl[j],False)
                        if len(sub4) > 0:
                            sub5 = False
                    if sub5:
                        sub = 1
                    else:
                        sub = 0
                elif not newBlocks[i][0] and not newBlocks[i][1] and not newBlocks[i][2] and not newBlocks[i][3]:
                    sub5 = True
                    for j in range(len(self.cl)):
                        sub4 = detectInter(sub2,self.cl[j],False)
                        if len(sub4) > 0:
                            sub5 = False
                    if sub5:
                        sub = 2
                    else:
                        sub = 0
                classBlocks.append([newBlocks[i][4][0],newBlocks[i][4][1],sub,newBlocks[i]])
                if sub == 1:
                    confirmed.append([newBlocks[i][4][0],newBlocks[i][4][1],s])
            sortedBlocks = [classBlocks[0]]
            for i in range(1,len(classBlocks)):
                count = i-1
                run = True
                while run:
                    if classBlocks[i][0] > sortedBlocks[count][0]:
                        sortedBlocks = insertIn(classBlocks[i],sortedBlocks,count+1)
                        run = False
                    if classBlocks[i][0] == sortedBlocks[count][0]:
                        if classBlocks[i][1] > sortedBlocks[count][1]:
                            sortedBlocks = insertIn(classBlocks[i],sortedBlocks,count+1)
                            run = False
                    if count == 0 and run:
                        sortedBlocks = insertIn(classBlocks[i],sortedBlocks,0)
                        run = False
                    count -= 1
            classBlocks = sortedBlocks
            for i in range(len(classBlocks)):
                adjCheck = [-1,-1,-1,-1,-1]
                if i < len(classBlocks)-1:
                    if classBlocks[i+1][0] == classBlocks[i][0] and classBlocks[i+1][1] == classBlocks[i][1]+s:
                       adjCheck[0] = classBlocks[i+1][2]
                    run = True
                    count = i+1
                    while run:
                        if classBlocks[count][0]-classBlocks[i][0] > s:
                            run = False
                        if classBlocks[count][0]-classBlocks[i][0] == s:
                            if classBlocks[count][1] == classBlocks[i][1]:
                                adjCheck[1] = classBlocks[count][2]
                            if classBlocks[count][1] == classBlocks[i][1]+s:
                                adjCheck[4] = classBlocks[count][2]
                                run = False
                            if classBlocks[count][1] > classBlocks[i][1]:
                                run = False
                        count += 1
                        if count == len(classBlocks):
                           run = False
                if i > 0:
                    if classBlocks[i-1][0] == classBlocks[i][0] and classBlocks[i-1][1] == classBlocks[i][1]-s:
                        adjCheck[2] = classBlocks[i-1][2]
                    run = True
                    count = i-1
                    while run:
                        if classBlocks[count][0]-classBlocks[i][0] < -s:
                            run = False
                        if classBlocks[count][0]-classBlocks[i][0] == -s:
                            if classBlocks[count][1] == classBlocks[i][1]:
                                adjCheck[3] = classBlocks[count][2]
                                run = False
                            if classBlocks[count][1]<classBlocks[i][1]:
                               run=False
                        count -= 1
                        if count == -1:
                           run = False
                classBlocks[i].append(adjCheck)
            newPoints = []
            for i in range(len(classBlocks)):
                newPoints.append([classBlocks[i][0],classBlocks[i][1],classBlocks[i][3][0]])
                if classBlocks[i][2] == 0:
                    if classBlocks[i][4][1] == -1:
                        newPoints.append([classBlocks[i][0]+s,classBlocks[i][1],not norm])
                        newPoints.append([classBlocks[i][0]+s,classBlocks[i][1]+s/2,not norm])
                    if classBlocks[i][4][1] == 2:
                        newPoints.append([classBlocks[i][0]+s,classBlocks[i][1]+s/2,False])
                    if classBlocks[i][4][1] == 1 or classBlocks[i][4][1] == 3:
                        newPoints.append([classBlocks[i][0]+s,classBlocks[i][1]+s/2,True])
                    if classBlocks[i][4][0] == -1:
                        newPoints.append([classBlocks[i][0],classBlocks[i][1]+s,not norm])
                        newPoints.append([classBlocks[i][0]+s/2,classBlocks[i][1]+s,not norm])
                    if classBlocks[i][4][0] == 2:
                        newPoints.append([classBlocks[i][0]+s/2,classBlocks[i][1]+s,False])
                    if classBlocks[i][4][0] == 1 or classBlocks[i][4][0] == 3:
                        newPoints.append([classBlocks[i][0]+s/2,classBlocks[i][1]+s,True])
                    if classBlocks[i][4][0] == -1 and classBlocks[i][4][1] == -1 and classBlocks[i][4][4] == -1:
                        newPoints.append([classBlocks[i][0]+s,classBlocks[i][1]+s,not norm])
                    elif (classBlocks[i][4][0] == -1 or classBlocks[i][4][0] == 2) and (classBlocks[i][4][1] == -1 or classBlocks[i][4][1] == 2) and (classBlocks[i][4][4] == -1 or classBlocks[i][4][4] == 2):
                        newPoints.append([classBlocks[i][0]+s,classBlocks[i][1]+s,False])
                    elif (classBlocks[i][4][0] == -1 or classBlocks[i][4][0] == 1 or classBlocks[i][4][0] == 3) and (classBlocks[i][4][1] == -1 or classBlocks[i][4][1] == 1 or classBlocks[i][4][1] == 3) and (classBlocks[i][4][4] == -1 or classBlocks[i][4][4] == 1 or classBlocks[i][4][4] == 3):
                        newPoints.append([classBlocks[i][0]+s,classBlocks[i][1]+s,True])
                    if classBlocks[i][4][2] == -1:
                        newPoints.append([classBlocks[i][0]+s/2,classBlocks[i][1],not norm])
                    elif classBlocks[i][4][2] == 2:
                        newPoints.append([classBlocks[i][0]+s/2,classBlocks[i][1],False])
                    elif classBlocks[i][4][2] == 1 or classBlocks[i][4][2] == 3:
                        newPoints.append([classBlocks[i][0]+s/2,classBlocks[i][1],True])
                    else:
                        newPoints.append([classBlocks[i][0]+s/2,classBlocks[i][1],-1])
                    if classBlocks[i][4][3] == -1:
                        newPoints.append([classBlocks[i][0],classBlocks[i][1]+s/2,not norm])
                    elif classBlocks[i][4][3] == 2:
                        newPoints.append([classBlocks[i][0],classBlocks[i][1]+s/2,False])
                    elif classBlocks[i][4][3] == 1 or classBlocks[i][4][3] == 3:
                        newPoints.append([classBlocks[i][0],classBlocks[i][1]+s/2,True])
                    else:
                        newPoints.append([classBlocks[i][0],classBlocks[i][1]+s/2,-1])
                    newPoints.append([classBlocks[i][0]+s/2,classBlocks[i][1]+s/2,-1])
            for i in range(len(newPoints)):
                if newPoints[i][2] == -1:
                    newPoints[i][2] = self.inside(orderedPair(newPoints[i][0],newPoints[i][1]),norm)
            sortedPoints = [newPoints[0]]
            for i in range(1,len(newPoints)):
                count = i-1
                run = True
                while run:
                    if newPoints[i][0] > sortedPoints[count][0]:
                        sortedPoints = insertIn(newPoints[i],sortedPoints,count+1)
                        run = False
                    if newPoints[i][0] == sortedPoints[count][0]:
                        if newPoints[i][1] > sortedPoints[count][1]:
                            sortedPoints = insertIn(newPoints[i],sortedPoints,count+1)
                            run = False
                    if count == 0:
                       run = False
                    count -= 1
            for i in range(len(sortedPoints)-1,0,-1):
                if sortedPoints[i][0] == sortedPoints[i-1][0] and sortedPoints[i][1] == sortedPoints[i-1][1]:
                    sortedPoints[i-1:i] = []
            ac = []
            for i in range(len(classBlocks)):
                if classBlocks[i][2] == 3 or classBlocks[i][2] == 1:
                    if not ((classBlocks[i][4][0] == 3 or classBlocks[i][4][0] == 1) and (classBlocks[i][4][1] == 3 or classBlocks[i][4][1] == 1) and (classBlocks[i][4][2] == 3 or classBlocks[i][4][2] == 1) and (classBlocks[i][4][3] == 3 or classBlocks[i][4][3] == 1)):
                        ac.append([classBlocks[i][0],classBlocks[i][1]])
                    sub = True
                    for j in range(4):
                        if not ((classBlocks[i][4][j] == 3 or classBlocks[i][4][j] == 1) and (classBlocks[i][4][(j+1)%4] == 3 or classBlocks[i][4][(j+1)%4] == 1) and (classBlocks[i][4][(j+2)%4] == 3 or classBlocks[i][4][(j+2)%4] == 1) and classBlocks[i][4][(j+3)%4] == -1):
                            sub = False
                    for j in range(4):
                        if not ((classBlocks[i][4][j] == 3 or classBlocks[i][4][j] == 1) and (classBlocks[i][4][(j+1)%4] == 3 or classBlocks[i][4][(j+1)%4] == 1) and classBlocks[i][4][(j+2)%4] == -1 and classBlocks[i][4][(j+3)%4] == -1):
                            sub = False
                    if sub:
                        ac.append([classBlocks[i][0],classBlocks[i][1]])
            final.append([sortedPoints,ac])
        squares = []
        for i in range(len(confirmed)):
            squares.append(fillSquare(orderedPair(int(confirmed[i][0]),int(confirmed[i][1])),int(confirmed[i][2])))
        return squares

"""
the findInter function - input: para object, para object | output: array of intersection objects
takes two para objects f1 and f2 and finds any intersections between them. intersections are returned as an array of intersection objects
similar to detectInter, but this function offers more exact figures
"""
def findInter(f1,f2):
    final = []
    estimates = detectInter(f1,f2,"es")
    for z in range(len(estimates)):
        subFinal = [estimates[z].prog1,estimates[z].prog2]
        finalIndex = [0,0]
        subStartPoint = 0
        if len(estimates) > 1:
            if z == 0:
                subStartPoint=min(abs(estimates[0].prog1-estimates[1].prog1),abs(estimates[0].prog2-estimates[1].prog2))
            elif z == len(estimates)-1:
                subStartPoint=min(abs(estimates[-1].prog1-estimates[-2].prog1),abs(estimates[-1].prog2-estimates[-2].prog2))
            else:
                subStartPoint=min(min(abs(estimates[z-1].prog1-estimates[z].prog1),abs(estimates[z-1].prog2-estimates[z].prog2)),min(abs(estimates[z+1].prog1-estimates[z].prog1),abs(estimates[z+1].prog2-estimates[z].prog2)))
            startPoint = abs(math.floor(math.log(subStartPoint,10)))+1
        else:
            count = 0
            while f1.positions[count] < subFinal[0]:
                count += 1
            mag1 = math.sqrt(pow(f1.deriv[count].x,2)+pow(f1.deriv[count].y,2))
            count = 0
            while f2.positions[count] < subFinal[1]:
                count += 1
            mag2 = math.sqrt(pow(f2.deriv[count].x,2)+pow(f2.deriv[count].y,2))
            startPoint = abs(math.floor(math.log(max(mag1,mag2),10)))
        for i in range(10):
            sampleDist = 100
            for j in range(21):
                for k in range(21):
                    p1 = subFinal[0]+(j-10)/pow(10,i+startPoint)
                    p2 = subFinal[1]+(k-10)/pow(10,i+startPoint)
                    sp1 = f1.f(p1)
                    sp2 = f2.f(p2)
                    tDis = dist(sp1,sp2)
                    if tDis < sampleDist:
                        finalIndex = [j-10,k-10]
                        sampleDist = tDis
            subFinal[0]+=finalIndex[0]/pow(10,i+startPoint)
            subFinal[1]+=finalIndex[1]/pow(10,i+startPoint)
        final.append(intersection(subFinal[0],subFinal[1]))
    return final

"""
the slicePara function - input: para object, number, number | output: para object
takes a para object and slices its polynomial nodes in its x and y attributes
"""
def slicePara(x,s,e):
    final=copyPara(x)
    for i in range(len(final.x.l)):
        if final.x.l[i].type == 0:
            final.x.l[i].value=slicePoly(final.x.l[i].value,s,e)
    for i in range(len(final.y.l)):
        if final.y.l[i].type == 0:
            final.y.l[i].value=slicePoly(final.y.l[i].value,s,e)
    return final

"""
the tangent function - input: para object, number, para object, number | output: para object
takes a base para object b and maps sample para object s based off of the reference points given. the sample curve is rotated so that it has the same direction as the base curve
"""
def tangent(b,bp,s,sp):
    final=para(s.x,s.y)
    stp = s.f(sp)
    sub = transformationNode([0,-stp.x,-stp.y])
    final=transformCurve([final],[sub])[0]
    ds = dPara(s)
    db = dPara(b)
    sa=daCent(ds.f(sp))
    ba=daCent(db.f(bp))
    sub2 = transformationNode([1,ba-sa])
    bap = b.f(bp)
    sub3 = transformationNode([0,bap.x,bap.y])
    final=transformCurve([final],[sub2,sub3])[0]
    return optPara(final)

"""
the addFull function - input: array of full objects, array of booleans | output: full object
takes an array of full objects and adds them all together resulting in one final full object. the array of booleans indicated whether its respective full object is negated
"""
def addFull(x,n):
    final=full([])
    ind=[]
    for i in range(len(x)):
        final.attach(x[i])
        ind.append(final.s()-1)
        if n[i]:
            if final.l[-1].type<3:
                final.l[-1].negate = not final.l[-1].negate
            else:
                final.l[-1].value*=-1
    sub=[]
    for i in range(len(ind)):
        sub.append([ind[i]])
    final.append([1,sub,0,False])
    return final

"""
the multFull function - input: array of full objects | output: full object
takes an array of full objects and multiplies them all together resulting in one final full object
"""
def multFull(x):
    final=full([])
    ind=[]
    for i in range(len(x)):
        final.attach(x[i])
        ind.append(final.s()-1)
    final.append([1,[ind],0,False])
    return final
"""
the leg function - input: positive number, number, number | output: poly object
used in tandem with customLeg to make bSpline segments
"""
def leg(n,l,c):
    a=[]
    for i in range(n):
        a.append([])
    for i in range(n):
        if i == l:
            a[0].append([[i]])
        elif i == l-1:
            a[0].append([[-(i+2)]])
        else:
            a[0].append(False)
    for m in range(n-1):
        for i in range(n-(m+1)):
            sub2=[]
            sub=[]
            if not a[m][i] == False:
                for j in range(len(a[m][i])):
                    for k in range(len(a[m][i][j])):
                        sub.append(a[m][i][j][k])
                    sub.append(i)
                    sub2.append(sub)
                    sub=[]
            sub=[]
            if not a[m][i+1] == False:
                for j in range(len(a[m][i+1])):
                    for k in range(len(a[m][i+1][j])):
                        sub.append(a[m][i+1][j][k])
                    sub.append(-(i+m+3))
                    sub2.append(sub)
                    sub=[]
            if a[m][i] == False and a[m][i+1] == False:
                sub2=False
            a[m+1].append(sub2)
    cL=a[n-1][0]
    gFinal=[]
    for i in range(n+1):
        gFinal.append(0)
    for j in range(len(cL)):
        prod=poly([1])
        for i in range(len(cL[j])):
            sub=[]
            if cL[j][i]<-1:
                sub=[-1,-cL[j][i]]
            else:
                sub=[1,-cL[j][i]]
            prod=multPoly(prod,poly(sub))
        for i in range(len(prod.c)):
            gFinal[i]+=prod.c[i]
    gFinal=horShift(poly(gFinal),-l)
    f=c/math.factorial(n)
    for i in range(len(gFinal.c)):
        gFinal.c[i]*=f
    return gFinal

"""
the customLeg function - input: array of numbers, number, number, boolean | output: poly object
used in tandem with leg to make bSpline segments. if t is set to true, the segments returned will be rounded
"""
def customLeg(p,d,l,t):
    points=[]
    if t == 0:
        for i in range(d-1):
            points.append(p[0])
        for i in range(len(p)):
            points.append(p[i])
        for i in range(d-1):
            points.append(p[len(p)-1])
    if t == 1:
        for i in range(len(p)):
            points.append(p[i])
        for i in range(d):
            points.append(points[i])
    pol=[0]
    for i in range(d):
        pol.append(0)
    for i in range(d+1):
        a=leg(d,d-i,points[i+l])
        sub=0
        for m in range(d+1):
            pol[m]+=a.c[m]
    return poly(pol)

"""
the bSpline function - input: orderedPair object, array of orderedPair objects, orderedPair object, number, boolean | output: array of para objects
takes control point in the form of orderedPair objects and returns a array of curves in a bSpline pattern. if t is set to true, the segments returned will be rounded
"""
def bSpline(sp,cp,ep,d,t):
    px = [sp.x]
    py = [sp.y]
    for k in range(len(cp)):
        px.append(cp[k].x)
        py.append(cp[k].y)
    px.append(ep.x)
    py.append(ep.y)
    final = []
    for k in range(len(px)+(d-2)*(not t)):
        final.append(optPara(para(full([fullNode([0,customLeg(px,d,k,t),0,False])]),full([fullNode([0,customLeg(py,d,k,t),0,False])]))))
    return final

"""
the doubleWarp function - input: para object, para object, array of para objects, scopeDimensions object, quickTranslate object | output: para object
like singleWarp, except two base curves are used instead of one
"""
def doubleWarp(b1,b2,sl,d,o):
    final = []
    for i in range(len(sl)):
        s = sl[i]
        sx=copyFull(s.x)
        sx.append([3,o.x])
        sx.append([1,[[-2],[-1]],0,False])
        sx.append([3,d.w])
        sx.append([2,[-2,-1],0,False])
        sy=copyFull(s.y)
        sy.append([3,o.y])
        sy.append([1,[[-2],[-1]],0,False])
        sy.append([3,d.h])
        sy.append([2,[-2,-1],0,False])
        xc1=comp(b1.x,sx)
        yc1=comp(b1.y,sx)
        xc2=comp(b2.x,sx)
        yc2=comp(b2.y,sx)
        xd=addFull([xc1,xc2],[True,False])
        yd=addFull([yc1,yc2],[True,False])
        xc3=multFull([xd,sy])
        yc3=multFull([yd,sy])
        xc4=addFull([xc1,xc3],[False,False])
        yc4=addFull([yc1,yc3],[False,False])
        final.append(para(xc4,yc4))
    return final

"""
the quadWarp function - input: para object, para object, para object, para object, array of para objects, scopeDimensions object, quickTranslate object | output: para object
like singleWarp, except four base curves are used instead of one
"""
def quadWarp(na,sa,ea,wa,sl,d,o):
    final=[]
    for z in range(len(sl)):
        s=sl[z]
        fsx=copyFull(s.x)
        fsx.append([3,o.x])
        fsx.append([1,[[-2],[-1]],0,False])
        fsx.append([3,d.w])
        fsx.append([2,[-2,-1],0,False])
        fsy=copyFull(s.y)
        fsy.append([3,o.y])
        fsy.append([1,[[-2],[-1]],0,False])
        fsy.append([3,d.h])
        fsy.append([2,[-2,-1],0,False])
        pax=comp(na.x,fsx)
        pay=comp(na.y,fsx)
        pbx=comp(sa.x,fsx)
        pby=comp(sa.y,fsx)
        hdx=addFull([multFull([addFull([pax,pbx],[True,False]),fsy]),pax],[False,False])
        hdy=addFull([multFull([addFull([pay,pby],[True,False]),fsy]),pay],[False,False])
        sas = sa.f(0)
        sae = sa.f(1)
        nas = na.f(0)
        nae = na.f(1)
        bpx=addFull([multFull([full([fullNode([3,sas.x-nas.x])]),fsy]),full([fullNode([3,nas.x])])],[False,False])
        bpy=addFull([multFull([full([fullNode([3,sas.y-nas.y])]),fsy]),full([fullNode([3,nas.y])])],[False,False])
        epx=addFull([multFull([full([fullNode([3,sae.x-nae.x])]),fsy]),full([fullNode([3,nae.x])])],[False,False])
        epy=addFull([multFull([full([fullNode([3,sae.y-nae.y])]),fsy]),full([fullNode([3,nae.y])])],[False,False])
        pcx=comp(wa.x,fsy)
        pcy=comp(wa.y,fsy)
        pdx=comp(ea.x,fsy)
        pdy=comp(ea.y,fsy)
        fx=addFull([hdx,pcx,bpx,multFull([addFull([pdx,pcx,bpx,epx],[False,True,False,True]),fsx])],[False,False,True,False])
        fy=addFull([hdy,pcy,bpy,multFull([addFull([pdy,pcy,bpy,epy],[False,True,False,True]),fsx])],[False,False,True,False])
        final.append(para(fx,fy))
    return final

"""
the cLine function - input: orderedPair object, orderedPair object | output: ps object
takes two points, finds the midpoint, and centers a line perpendicular to the slope of the line formed by the first two points
"""
def cLine(p1,p2):
    mid=midpoint(p1,p2)
    return ps(orderedPair(mid.x+(mid.y-p2.y),mid.y+(mid.x-p1.x)),orderedPair(mid.x-(mid.y-p2.y),mid.y+(mid.x-p2.x)))

"""
the cloPoints function - input: array of orderedPair objects, orderedPair object, boolean | output: array of two numbers
takes a list of points and finds the closest point on either side of a midpoint set
"""
def cloPoints(pospo,mid,yf):
    sub=mid.y
    if yf:
        sub=mid.x
    posPoints=[]
    negPoints=[]
    for i in range(len(pospo)):
        if yf:
            if pospo[i].x>sub:
                posPoints.append(i)
            else:
                negPoints.append(i)
        else:
            if pospo[i].y>sub:
                posPoints.append(i)
            else:
                negPoints.append(i)
    lp=posPoints[0]
    ln=negPoints[0]
    for i in range(len(posPoints)):
        sub2=pospo[posPoints[i]].y
        sub3=pospo[lp].y
        if yf:
            sub2=pospo[posPoints[i]].x
            sub3=pospo[lp].x
        if abs(sub2-sub)<abs(sub3-sub):
            lp=posPoints[i]
    for i in range(len(negPoints)):
        sub2=pospo[negPoints[i]].y
        sub3=pospo[ln].y
        if yf:
            sub2=pospo[negPoints[i]].x
            sub3=pospo[ln].x
        if abs(sub2-sub)<abs(sub3-sub):
            ln=negPoints[i]
    return [ln,lp]

"""
the sideSearch function - input: array of orderedPair objects, boolean, orderedPair object, boolean | output: number
takes a list of points and finds the closest point on a certain side of a line
"""
def sideSearch(pospo,s,mid,yf):
    sub = mid.y
    if yf:
        sub = mid.x
    confirmedSide=[]
    for i in range(len(pospo)):
        sub2 = pospo[i].y
        if yf:
            sub2 = pospo[i].x
        if (sub2<sub and s) or (sub2>sub and not s):
            confirmedSide.append(i)
    final=confirmedSide[0]
    for i in range(len(confirmedSide)):
        sub2 = pospo[confirmedSide[i]].y
        sub3 = pospo[final].y
        if yf:
            sub2 = pospo[confirmedSide[i]].x
            sub3 = pospo[final].x
        if abs(sub2-sub)<abs(sub3-sub):
            final=confirmedSide[i]
    return final

"""
the customBorder function - input: ps object, bounds object | output: two dimensional array
takes ps object and makes a line that lies within a given range
"""
def customBorder(l,bo):
    r = [bo.minX,bo.minY,bo.maxX,bo.maxY]
    cor=0
    if not l.yFunc:
        cor=1
    endPoints=[[l.f(r[cor]).x,l.f(r[cor]).y],[l.f(r[cor+2]).x,l.f(r[cor+2]).y]]
    for i in range(2):
        if endPoints[0][i]<r[i]:
            sub = (r[i]-l.b)/l.m
            endPoints[0]=[l.f(sub).x,l.f(sub).y]
        if endPoints[0][i]>r[i+2]:
            sub = (r[i+2]-l.b)/l.m
            endPoints[0]=[l.f(sub).x,l.f(sub).y]
        if endPoints[1][i]<r[i]:
            sub = (r[i]-l.b)/l.m
            endPoints[1]=[l.f(sub).x,l.f(sub).y]
        if endPoints[1][i]>r[i+2]:
            sub = (r[i+2]-l.b)/l.m
            endPoints[1]=[l.f(sub).x,l.f(sub).y]
    return endPoints

"""
the voronoi function - input: prism, array of orderedPair objects | output: array of para objects, array of prism objects
takes a list of points and makes a voronoi diagram. the diagram is set within the prism given. returns an array of para objects that represent lines and an array of prism objects that represent the subprisms created by the lines

uses cLine, cloPoints, customBorder, and sideSearch functions
"""
def voronoi(pr,pl):
    allLines=[]
    compMap=[]
    isBorders=[]
    bpUsed = []
    allBP = []
    for i in range(len(pr.cl)):
        bpUsed.append([])
    for i in range(len(pl)):
        compMap.append([])
        for j in range(len(pl)):
            if i == j:
                compMap[i].append(True)
            else:
                compMap[i].append(False)
    for sel in range(len(pl)):
        sub=[]
        for i in range(len(pl)):
            if not i == sel:
                sub.append([dist(pl[sel],pl[i]),i])
        sortedL=[]
        l=sub[0][0]
        ind=0
        c=0
        while len(sub)>0:
            if l>sub[c][0]:
                l=sub[c][0]
                ind=c
            c += 1
            if c == len(sub):
                sortedL.append(sub[ind])
                sub[ind:ind+1] = []
                if len(sub)>0:
                    c=0
                    ind=0
                    l=sub[0][0]
        midLines=[]
        m=0
        for i in range(len(sortedL)):
            midLines.append(cLine(pl[sel],pl[sortedL[i][1]]))
            if i == 0:
                m=midpoint(pl[sel],pl[sortedL[i][1]])
        possPoints=[]
        possPointsBord=[]
        intPoints=[]
        sub=customBorder(midLines[0],pr.bounds)
        sub2=bez([sub[0][0],sub[0][1]],[],[sub[1][0],sub[1][1]])
        configData(sub2)
        for j in range(len(pr.cl)):
            sub3=findInter(sub2,pr.cl[j])
            for k in range(len(sub3)):
                possPoints.append(sub2.f(sub3[k].prog1))
                possPointsBord.append([j,sub3[k].prog2])
                intPoints.append(-1)
        for i in range(1,len(midLines)):
            iSamp=psInter(midLines[0],midLines[i])
            if pr.bounds.inBounds(iSamp):
                possPoints.append(iSamp)
                possPointsBord.append(-1)
                intPoints.append(i)
        a=cloPoints(possPoints,m,midLines[0].yFunc)
        b=0
        searcher=[]
        sideTest=midLines[0].angDir(pl[sel])
        for i in range(len(a)):
            if intPoints[a[i]]>-1:
                searcher.append([intPoints[a[i]],possPoints[a[i]],0,(i == 1) == sideTest])
        finalLines=[]
        if not compMap[sel][sortedL[0][1]] and not compMap[sortedL[0][1]][sel]:
            finalLines.append([possPoints[a[0]].x,possPoints[a[0]].y,possPoints[a[1]].x,possPoints[a[1]].y])
            newPoint = True
            for z in range(len(allBP)):
                if pComp(allBP[z], possPoints[a[0]]):
                    newPoint = False
            if newPoint:
                allBP.append(possPoints[a[0]])
            newPoint = True
            for z in range(len(allBP)):
                if pComp(allBP[z], possPoints[a[1]]):
                    newPoint = False
            if newPoint:
                allBP.append(possPoints[a[1]])
            isBorders.append([intPoints[a[0]] == -1,intPoints[a[1]] == -1])
            if not possPointsBord[a[0]] == -1:
                bpUsed[possPointsBord[a[0]][0]].append(possPointsBord[a[0]][1])
            if not possPointsBord[a[1]] == -1:
                bpUsed[possPointsBord[a[0]][0]].append(possPointsBord[a[1]][1])
        compMap[sel][sortedL[0][1]]=True
        compMap[sortedL[0][1]][sel]=True
        while len(searcher)>0:
            searcherInts=[]
            searcherBP = []
            linePoints=[]
            sub=customBorder(midLines[searcher[0][0]],pr.bounds)
            sub2=bez([sub[0][0],sub[0][1]],[],[sub[1][0],sub[1][1]])
            configData(sub2)
            for j in range(len(pr.cl)):
                sub3=findInter(sub2,pr.cl[j])
                for k in range(len(sub3)):
                    searcherInts.append(sub2.f(sub3[k].prog1))
                    searcherBP.append([j,sub3[k].prog2])
                    linePoints.append(-1)
            for i in range(len(midLines)):
                if not i == searcher[0][0] and not i == searcher[0][2]:
                    iSamp=psInter(midLines[i],midLines[searcher[0][0]])
                    if pr.bounds.inBounds(iSamp):
                        searcherInts.append(iSamp)
                        searcherBP.append(-1)
                        linePoints.append(i)
            sideTest=midLines[searcher[0][0]].angDir(pl[sel])
            a=sideSearch(searcherInts,not sideTest == searcher[0][3],searcher[0][1],midLines[searcher[0][0]].yFunc)
            if linePoints[a]>0:
                searcher.append([linePoints[a],searcherInts[a],searcher[0][0],searcher[0][3]])
            if not compMap[sel][sortedL[searcher[0][0]][1]] and not compMap[sortedL[searcher[0][0]][1]][sel]:
                finalLines.append([searcher[0][1].x,searcher[0][1].y,searcherInts[a].x,searcherInts[a].y])
                newPoint = True
                for z in range(len(allBP)):
                    if pComp(allBP[z], searcher[0][1]):
                        newPoint = False
                if newPoint:
                    allBP.append(searcher[0][1])
                newPoint = True
                for z in range(len(allBP)):
                    if pComp(allBP[z], searcherInts[a]):
                        newPoint = False
                if newPoint:
                    allBP.append(searcherInts[a])
                isBorders.append([False,linePoints[a] == -1])
                if not searcherBP[a] == -1:
                    bpUsed[searcherBP[a][0]].append(searcherBP[a][1])
            compMap[sel][sortedL[searcher[0][0]][1]]=True
            compMap[sortedL[searcher[0][0]][1]][sel]=True
            searcher[0:1] = []
        for i in range(len(finalLines)):
            allLines.append(finalLines[i])
    for i in range(len(pr.cl)):
        allBP.append(pr.cl[i].main[0])
    paraLines = []
    for i in range(len(allLines)):
        sub = bez([allLines[i][0],allLines[i][1]],[],[allLines[i][2],allLines[i][3]])
        configData(sub)
        paraLines.append(sub)
    sortedBP = []
    for i in range(len(bpUsed)):
        sortedBP.append([0])
        sub = []
        count = 0
        lowest = [0,bpUsed[i][0]]
        while len(bpUsed[i]) > 0:
            if bpUsed[i][count] < bpUsed[i][lowest[0]]:
                lowest = [count,bpUsed[i][count]]
            count += 1
            if count == len(bpUsed[i]):
                sortedBP[i].append(bpUsed[i][lowest[0]])
                bpUsed[i][lowest[0]:lowest[0]+1] = []
                if len(bpUsed[i]) > 0:
                    count = 0
                    lowest = [count,bpUsed[i][count]]
        sortedBP[-1].append(1)
    newBorders = []
    for i in range(len(paraLines)):
        newBorders.append(paraLines[i])
    for i in range(len(sortedBP)):
        for j in range(len(sortedBP[i])-1):
            sub = slicePara(pr.cl[i],sortedBP[i][j],sortedBP[i][j+1])
            configData(sub)
            newBorders.append(sub)
    subPrisms = []
    for i in range(len(pl)):
        spSides = []
        run = True
        while run:
            if len(spSides) == 0:
                sub = bez([pl[i].x,pl[i].y],[],[pr.bounds.maxX,pl[i].y])
                configData(sub)
                lowest = [0,pr.bounds.maxX]
                for j in range(len(newBorders)):
                    sub2 = findInter(sub,newBorders[j])
                    for k in range(len(sub2)):
                        sub3 = sub.f(sub2[k].prog1)
                        if sub3.x < lowest[1]:
                            lowest = [k,sub3.x]
                spSides.append([lowest[0],da2(pl[i],newBorders[lowest[0]].main[0]) < da2(pl[i],newBorders[lowest[0]].main[-1])])
            else:
                nextPoint = newBorders[spSides[-1][0]].main[-int(not spSides[-1][1])]
                options = []
                for j in range(len(newBorders)):
                    used = False
                    for k in range(len(spSides)):
                        if j == spSides[k][0]:
                            used = True
                    if not used:
                        if pComp(newBorders[j].main[0],nextPoint):
                            options.append([j,False,da2(pl[i],newBorders[j].main[-1])])
                        elif pComp(newBorders[j].main[-1],nextPoint):
                            options.append([j,True,da2(pl[i],newBorders[j].main[0])])
                highest = [0,options[0][2]]
                for k in range(len(options)):
                    if options[k][2] > highest[1]:
                        highest = [k,options[k][2]]
                spSides.append([options[highest[0]][0],options[highest[0]][1]])
                run = not pComp(newBorders[spSides[-1][0]].main[-1],newBorders[spSides[0][0]].main[0])
        sub2 = []
        for j in range(len(spSides)):
            sub = newBorders[spSides[j][0]]
            if spSides[j][1]:
                sub = slicePara(sub,1,0)
            sub2.append(sub)
        subPrisms.append(prism(sub2))
    for i in range(len(paraLines)):
        sp = paraLines[i].f(0)
        ep = paraLines[i].f(1)
        sub = "[1,["
        sub += str(sp.x)
        sub += ","
        sub += str(sp.y)
        sub += "],[],["
        sub += str(ep.x)
        sub += ","
        sub += str(ep.y)
        sub += "],[1.5,0,1,0,"
        if nodeConfig[i][0]:
            sub += "1"
        else:
            sub += "0"
        sub += ",1,"
        if nodeConfig[i][1]:
            sub += "1"
        else:
            sub += "0"
        sub += "]],"
        print(sub)
    return [paraLines,subPrisms]

"""
the optFull function - input: full object | output: full object
takes a full object and optimizes it by removing useless entries(e.g. zero entries and redundant values)
"""
def optFull(f):
    final=[]
    if len(f.l) == 0:
        return f
    if f.l[len(f.l)-1].type == 0:
        final.append(f.l[-1])
        return full(final)
    final=copyFull(f)
    keepList=[]
    for i in range(len(f.l)):
        keepList.append(False)
    zeros=[]
    ones=[]
    for i in range(len(f.l)):
        if f.l[i].type == 0:
            if len(f.l[i].value.c) == 0:
                zeros.append(i)
            elif len(f.l[i].value.c) == 1 and f.l[i].value.c[0] == 0:
                zeros.append(i)
            elif len(f.l[i].value.c) == 1 and not f.l[i].value.c[0] == 0:
                sub=f.l[i].value.c[0]
                if f.l[i].function == 1:
                    if sub>=0:
                        sub=math.sqrt(sub)
                    else:
                        keepList[i]=False
                elif f.l[i].function == 2:
                    sub=math.sin(sub)
                elif f.l[i].function == 3:
                    sub=math.cos(sub)
                sub*=pow(-1,f.l[i].negate)
                if sub == 1:
                    ones.append(i)
                final.l[i]=fullNode([3,sub])
        elif f.l[i].type == 3:
            if f.l[i].value == 0:
                zeros.append(i)
            elif f.l[i].value == 1:
                ones.append(i)
    uniques=[]
    copies=[]
    for i in range(len(final.l)):
        if len(uniques) == 0:
            uniques.append(i)
        else:
            found=False
            count=0
            if final.l[i].type == 0:
                while count<len(uniques) and not found:
                    if final.l[uniques[count]].type == 0 and final.l[uniques[count]].function == final.l[i].function and final.l[uniques[count]].negate == final.l[i].negate:
                        found = False
                        if final.l[uniques[count]].type == final.l[i].type:
                            if len(final.l[uniques[count]].value.c) == len(final.l[i].value.c):
                                found = True
                                count2 = 0
                                while count2 < len(final.l[uniques[count]].value.c) and found:
                                    if not final.l[uniques[count]].value.c[count2] == final.l[i].value.c[count2]:
                                        found = False
                                    count2 += 1
                    if not found:
                        count += 1
                if found:
                    copies.append([i,uniques[count]])
                else:
                    uniques.append(i)
            elif final.l[i].type == 1:
                while count<len(uniques) and not found:
                    if final.l[uniques[count]].type == 1 and final.l[uniques[count]].function == final.l[i].function and final.l[uniques[count]].negate == final.l[i].negate:
                        found = True
                        if not len(final.l[uniques[count]].value) == len(final.l[i].value):
                            found = False
                        else:
                            for j in range(len(final.l[uniques[count]].value)):
                                if not len(final.l[uniques[count]].value[j]) == len(final.l[i].value[j]):
                                    found = False
                                else:
                                    count2 = 0
                                    while count2 < len(final.l[uniques[count]].value[j]) and found:
                                        if not final.l[uniques[count]].value[j][count2] == final.l[i].value[j][count2]:
                                            found = False
                                        count2 += 1
                    if not found:
                        count += 1
                if found:
                    copies.append([i,uniques[count]])
                else:
                    uniques.append(i)
            elif final.l[i].type == 2:
                while count<len(uniques) and not found:
                    if final.l[uniques[count]].type == 2 and final.l[uniques[count]].function == final.l[i].function and final.l[uniques[count]].negate == final.l[i].negate:
                        found = False
                        if final.l[uniques[count]].type == final.l[i].type:
                            if len(final.l[uniques[count]].value) == len(final.l[i].value):
                                found = True
                                count2 = 0
                                while count2 < len(final.l[uniques[count]].value) and found:
                                    if not final.l[uniques[count]].value[count2] == final.l[i].value[count2]:
                                        found = False
                                    count2 += 1
                    if not found:
                        count += 1
                if found:
                    copies.append([i,uniques[count]])
                else:
                    uniques.append(i)
            elif final.l[i].type == 3:
                while count<len(uniques) and not found:
                    if final.l[uniques[count]].type == 3:
                        found=(final.l[uniques[count]].value == final.l[i].value)
                    if not found:
                        count += 1
                if found:
                    copies.append([i,uniques[count]])
                else:
                    uniques.append(i)
    singles=[]
    for i in range(len(f.l)):
        if f.l[i].type == 1:
            if len(f.l[i].value) == 1 and f.l[i].function == 0 and not f.l[i].negate:
                if len(f.l[i].value[0]) == 1:
                    ind=-1
                    for j in range(len(singles)):
                        for k in range(len(singles[j][1])):
                            if singles[j][1][k] == f.l[i].value[0][0]:
                                ind = j
                    if ind == -1:
                        singles.append([f.l[i].value[0][0],[i]])
                    else:
                        singles[ind][1].append(i)
    totRa=[]
    for i in range(len(f.l)):
        totRa.append(-1)
    for i in range(len(singles)):
        for j in range(len(singles[i][1])):
            totRa[singles[i][1][j]]=singles[i][0]
            keepList[singles[i][1][j]]=False
    for i in range(len(copies)):
        totRa[copies[i][0]]=copies[i][1]
        keepList[copies[i][0]]=False
    for i in range(0):
        sub=singleDep(f,ones[i])
        for j in range(len(sub)):
            if f.l[sub[j]].type == 1:
                sub3=[]
                for m in range(len(f.l[sub[j]].value)):
                    sub3.append([])
                    for k in range(len(f.l[sub[j]].value[m])):
                        if k == 0:
                            sub3[m].append(f.l[sub[j]].value[m][k])
                        else:
                            if not f.l[sub[j]].value[m][k] == ones[i]:
                                sub3[m].append(f.l[sub[j]].value[m][k])
                if len(sub3) == 1:
                    if len(sub3.type) == 1:
                        totRa[sub[j]]=sub3[0][0]
                    else:
                        final.l[sub[j]].value=sub3
                else:
                    final.l[sub[j]].value=sub3
            else:
                if f.l[sub[j]].value[1] == ones[i]:
                    totRa[sub[j]]=f.l[sub[j]].value[0]
    for i in range(len(f.l)):
        if f.l[i].type == 1:
            for j in range(len(f.l[i].value)):
                for k in range(len(f.l[i].value[j])):
                    if totRa[f.l[i].value[j][k]]>-1:
                        final.l[i].value[j][k]=totRa[f.l[i].value[j][k]]
        elif f.l[i].type == 2:
            for j in range(len(f.l[i].value)):
                if totRa[f.l[i].value[j]]>-1:
                    final.l[i].value[j]=totRa[f.l[i].value[j]]
    sub=[[]]
    for i in range(len(zeros)):
        keepList[zeros[i]]=False
        sub2=singleDep(f,zeros[i])
        for j in range(len(sub2)):
            sub[0].append([zeros[i],sub2[j]])
    while len(sub[-1])>0:
        sub2=[]
        for i in range(len(sub[len(sub)-1])):
            if f.l[sub[len(sub)-1][i][1]].type == 2:
                sub3=singleDep(f,sub[len(sub)-1][i][1])
                for j in range(len(sub3)):
                    sub2.append([sub[len(sub)-1][i][1],sub3[j]])
            else:
                sub3=[]
                for j in range(len(f.l[sub[len(sub)-1][i][1]].value)):
                    keep=True
                    for k in range(len(f.l[sub[len(sub)-1][i][1]].value[j])):
                        if f.l[sub[len(sub)-1][i][1]].value[j][k] == sub[len(sub)-1][i][0]:
                            keep=False
                    if keep:
                        sub3.append(f.l[sub[len(sub)-1][i][1]].value[j])
                if len(sub3) == 0:
                    keepList[sub[len(sub)-1][i][1]]=False
                    sub4=singleDep(f,sub[len(sub)-1][i][1])
                    for j in range(len(sub4)):
                        sub2.append([sub[len(sub)-1][i][1],sub4[j]])
                final.l[sub[len(sub)-1][i][1]].value=sub3
        sub.append(sub2)
    newOnes=[]
    for i in range(len(final.l)):
        if final.l[i].type == 2:
            if final.l[i].value[0] == final.l[i].value[1]:
                newOnes.append(i)
            if final.l[final.l[i].value[0]].type == 3 and final.l[final.l[i].value[1]].type == 3:
                sub=final.l[final.l[i].value[0]].value/final.l[final.l[i].value[1]].value
                final.l[i].type = 3
                final.l[i].value = sub
    for i in range(len(newOnes)):
        sub=singleDep(f,newOnes[i])
        for j in range(len(sub)):
            if f.l[sub[j]].type == 1:
                sub3=[]
                for m in range(len(f.l[sub[j]].value)):
                    sub3.append([])
                    for k in range(len(f.l[sub[j]].value[m])):
                        if k == 0:
                            sub3[m].append(f.l[sub[j]].value[m][k])
                        else:
                            if not f.l[sub[j]].value[m][k] == sub[j]:
                                sub3[m].append(f.l[sub[j]].value[m][k])
                final.l[sub[j]].value=sub3
            else:
                if f.l[sub[j]].value[1] == ones[i]:
                    totRa[sub[j]]=f.l[sub[j]].value[0]
    for i in range(len(final.l)):
        if final.l[i].type == 1:
            for j in range(len(final.l[i].value)):
                for k in range(len(final.l[i].value[j])):
                    if totRa[final.l[i].value[j][k]]>-1:
                        final.l[i].value[j][k]=totRa[final.l[i].value[j][k]]
        elif final.l[i].type == 2:
            for j in range(len(final.l[i].value)):
                if totRa[final.l[i].value[j]]>-1:
                    final.l[i].value[j]=totRa[final.l[i].value[j]]
    initKeeps=reverseDependency(full(final.l),len(final.l)-1)
    for i in range(len(initKeeps)):
        keepList[initKeeps[i]]=True
    if keepList[len(keepList)-1] == False:
        return full([])
    fullDec=[]
    dec=0
    for i in range(len(keepList)):
        fullDec.append(dec)
        if not keepList[i]:
            dec += 1
    for i in range(len(final.l)-1,-1,-1):
        if keepList[i]:
            if final.l[i].type == 1:
                for j in range(len(final.l[i].value)):
                    for k in range(len(final.l[i].value[j])):
                        final.l[i].value[j][k]-=fullDec[final.l[i].value[j][k]]
            elif final.l[i].type == 2:
                for j in range(len(final.l[i].value)):
                    final.l[i].value[j]-=fullDec[final.l[i].value[j]]
        else:
            final.l[i:i+1] = []
    if final.l[-1].type == 1:
        if len(final.l[-1].value) == 1:
            if len(final.l[-1].value[0]) == 1:
                sub = final.l[-1].value[0][0]
                final.l[sub+1:] = []
    return final

"""
the anglePoint function - input: para object, number | output: number
takes a para object and returns the angle of its derivative vector at a given point
"""
def anglePoint(c,p):
    dc = dPara(c)
    return daCent(dc.f(p))

"""
the angleDeriv function - input: para object | output: full object
takes a para object and returns an expression that represents the derivative of its angle function
"""
def angleDeriv(c):
    dc = dPara(c)
    ddc = dPara(dc)
    sub = dc.x
    ix = len(sub.l)-1
    sub.attach(dc.y)
    iy = len(sub.l)-1
    sub.attach(ddc.x)
    dix = len(sub.l)-1
    sub.attach(ddc.y)
    diy = len(sub.l)-1
    sub.append([1,[[diy,ix]],0,False])
    sub.append([1,[[dix,iy]],0,True])
    sub.append([1,[[-2],[-1]],0,False])
    sub.append([1,[[ix,ix],[iy,iy]],0,False])
    sub.append([2,[-2,-1],0,False])
    return sub
